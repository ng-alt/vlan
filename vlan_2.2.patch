Only in linux/include/linux: coda_opstats.h
Only in linux/include/linux: dasd.h
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/include/linux/if_ether.h linux.dev/include/linux/if_ether.h
*** linux/include/linux/if_ether.h	Wed Jun  2 11:29:28 1999
--- linux.dev/include/linux/if_ether.h	Sat Oct 14 14:14:24 2000
***************
*** 33,36 ****
--- 33,66 ----
  #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
  
+ 
+ #ifdef 	CONFIG_VLAN_802_1Q
+ 
+ 
+ #define VLAN_ETH_ALEN	6		/* Octets in one ethernet addr	 */
+ #define VLAN_ETH_HLEN	18		/* Total octets in header.	 */
+ #define VLAN_ETH_ZLEN	64		/* Min. octets in frame sans FCS */
+ 
+ /* These could be bumped up by 4, but I'm not sure if all the underlying
+  * drivers would like it.
+  * UPDATE:  Bumping it by 4, as per Klika's suggestion below. --BLG
+  *
+  * According to 802.3ac, the packet can be 4 bytes longer. --Klika Jan
+  */
+ #define VLAN_ETH_DATA_LEN	1500	/* Max. octets in payload	 */
+ #define VLAN_ETH_FRAME_LEN	1518	/* Max. octets in frame sans FCS */
+ 
+ struct vlan_ethhdr 
+ {
+    unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+    unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+    unsigned short       h_vlan_proto;           /* Should always be 0x8100 */
+    unsigned short       h_vlan_TCI;             /* Encapsulates priority and VLAN ID */
+    unsigned short	h_vlan_encapsulated_proto; /* packet type ID field (or len) */
+ };
+ 
+ 
+ #endif
+ 
+ 
  /*
   *	These are the defined Ethernet Protocol ID's.
***************
*** 55,58 ****
--- 85,89 ----
  #define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
  #define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+ #define ETH_P_802_1Q	0x8100          /* 802.1Q VLAN Extended Header  */
  #define ETH_P_IPX	0x8137		/* IPX over DIX			*/
  #define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/include/linux/if_vlan.h linux.dev/include/linux/if_vlan.h
*** linux/include/linux/if_vlan.h	Wed Dec 31 17:00:00 1969
--- linux.dev/include/linux/if_vlan.h	Wed Oct 25 23:39:23 2000
***************
*** 0 ****
--- 1,238 ----
+ /* -*- linux-c -*-
+  * VLAN		An implementation of 802.1Q VLAN tagging.
+  *
+  * Version:	0.0.1	03/06/99
+  *
+  * Authors:	Ben Greear <greearb@candelatech.com>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  *
+  */
+ 
+ #ifndef _LINUX_IF_VLAN_H_
+ #define _LINUX_IF_VLAN_H_
+ 
+ #ifdef __KERNEL__
+ 
+ 
+ /* externally defined structs */
+ struct vlan_group;
+ struct device;
+ struct sk_buff;
+ struct packet_type;
+ struct vlan_collection;
+ 
+ 
+ #include <linux/proc_fs.h> /* for proc_dir_entry */
+ 
+ 
+ 
+ /*  Find a VLAN device by the MAC address of it's Ethernet device, and
+  *  it's VLAN ID.  The default configuration is to have VLAN's scope
+  *  to be box-wide, so the MAC will be ignored.  The mac will only be
+  *  looked at if we are configured to have a seperate set of VLANs per
+  *  each MAC addressable interface.  Note that this latter option does
+  *  NOT follow the spec for VLANs, but may be useful for doing very
+  *  large quantities of VLAN MUX/DEMUX onto FrameRelay or ATM PVCs.
+  */
+ struct device *find_802_1Q_vlan_dev(struct device* real_dev,
+                                     unsigned short VID); /* vlan.c */
+ 
+ 
+ int register_netdevice(struct device *dev); /* found in dev.c */
+ int unregister_netdevice(struct device *dev); /* found in dev.c */
+ int dev_new_index(void); /* dev.c */
+ 
+ /* found in vlan_dev.c */
+ struct net_device_stats* vlan_dev_get_stats(struct device* dev);
+ int vlan_dev_rebuild_header(struct sk_buff *skb);
+ int vlan_dev_type_trans(struct sk_buff *skb, struct device *dev,
+                         struct packet_type* ptype);
+ int vlan_dev_hard_header(struct sk_buff *skb, struct device *dev,
+                          unsigned short type, void *daddr, void *saddr,
+                          unsigned len);
+ int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct device *dev);
+ int vlan_dev_change_mtu(struct device *dev, int new_mtu);
+ int vlan_dev_set_mac_address(struct device *dev, void* addr);
+ int vlan_dev_open(struct device* dev);
+ int vlan_dev_stop(struct device* dev);
+ int vlan_dev_init(struct device* dev);
+ void vlan_dev_destruct(struct device* dev);
+ int vlan_dev_set_vlan_flag(char* dev_name, __u32 flag, short flag_val);
+ /*  I'm ignorant of these right now. --BLG
+ int vlan_dev_header_cache(struct neighbour *neigh, struct hh_cache *hh);
+ void vlan_dev_header_cache_update(struct hh_cache *hh, struct device *dev,
+                                   unsigned char * haddr);
+ */
+ void vlan_dev_copy_and_sum(struct sk_buff *dest, unsigned char *src,
+                            int length, int base);
+ int vlan_dev_set_ingress_priority(char* dev_name, __u32 skb_prio, short vlan_prio);
+ int vlan_dev_set_egress_priority(char* dev_name, __u32 skb_prio, short vlan_prio);
+ 
+ /* VLAN multicast stuff */
+ /* Delete all of the MC list entries from this vlan device.  Also deals
+  * with the underlying device...
+  */
+ void vlan_flush_mc_list(struct device* dev);
+ /* copy the mc_list into the vlan_info structure. */
+ void vlan_copy_mc_list(struct dev_mc_list* mc_list, struct vlan_dev_info* vlan_info);
+ /** dmi is a single entry into a dev_mc_list, a single node.  mc_list is
+  *  an entire list, and we'll iterate through it.
+  */
+ int vlan_should_add_mc(struct dev_mc_list *dmi, struct dev_mc_list *mc_list);
+ /** Taken from Gleb + Lennert's VLAN code, and modified... */
+ void vlan_dev_set_multicast_list(struct device *vlan_dev);
+ 
+ 
+ int vlan_collection_add_vlan(struct vlan_collection* vc, unsigned short vlan_id,
+                              unsigned short flags);
+ int vlan_collection_remove_vlan(struct vlan_collection* vc,
+                                 struct device* vlan_dev);
+ int vlan_collection_remove_vlan_id(struct vlan_collection* vc, unsigned short vlan_id);
+ 
+ 
+ 
+ /* found in vlan.c */
+ /* Our listing of VLAN group(s) */
+ extern struct vlan_group* p802_1Q_vlan_list;
+ 
+ 
+ #define VLAN_NAME "vlan"
+ 
+ /* if this changes, algorithm will have to be reworked because this
+  * depends on completely exhausting the VLAN identifier space.  Thus
+  * it gives constant time lookup, but it many cases it wastes memory.
+  */
+ #define VLAN_GROUP_ARRAY_LEN 4096
+ 
+ struct vlan_group {
+         int real_dev_ifindex; /* The index of the ethernet(like?) device the vlan is attached to. */
+         struct device* vlan_devices[VLAN_GROUP_ARRAY_LEN];
+    
+         struct vlan_group* next; /* the next in the list */
+ };
+ 
+ 
+ /* __Flags__ relating to the vlan ports */
+ #define VLAN_FLAG_ALLOW_802_3   1
+ #define VLAN_FLAG_ALLOW_802_1Q  2
+ #define VLAN_FLAG_IS_IN_USE     4
+ 
+ 
+ struct vlan_priority_tci_mapping {
+         unsigned long priority;
+         unsigned short vlan_qos; /* This should be shifted when first set, so we only do it
+                                   * at provisioning time.
+                                   * ((skb->priority << 13) & 0xE000)
+                                   */
+         struct vlan_priority_tci_mapping* next;
+ };
+ 
+ /* Holds information that makes sense if this device is a VLAN device. */
+ struct vlan_dev_info {
+         /** This will be the mapping that correlates skb->priority to
+          * 3 bits of VLAN QOS tags...
+          */
+         unsigned long ingress_priority_map[8];
+         struct vlan_priority_tci_mapping* egress_priority_map[16]; /* hash table */
+ 
+         unsigned short vlan_id;        /*  The VLAN Identifier for this interface. */
+         unsigned short flags;          /* (1 << 0) re_order_header   This option will cause the
+                                         *   VLAN code to move around the ethernet header on
+                                         *   ingress to make the skb look **exactly** like it
+                                         *   came in from an ethernet port.  This destroys some of
+                                         *   the VLAN information in the skb, but it fixes programs
+                                         *   like DHCP that use packet-filtering and don't understand
+                                         *   802.1Q
+                                         */
+         struct dev_mc_list* old_mc_list;  /* old multi-cast list for the VLAN interface..
+                                            * we save this so we can tell what changes were
+                                            * made, in order to feed the right changes down
+                                            * to the real hardware...
+                                            */
+         int old_allmulti;               /* similar to above. */
+         int old_promiscuity;            /* similar to above. */
+         struct device* real_dev;        /* the underlying device/interface */
+         struct proc_dir_entry dent;    /* Holds the proc data */
+         unsigned long cnt_inc_headroom_on_tx; /* How many times did we have to grow the skb on TX. */
+         unsigned long cnt_encap_on_xmit;      /* How many times did we have to encapsulate the skb on TX. */
+ };
+ 
+ static inline unsigned short vlan_dev_get_egress_qos_mask(struct device* dev, struct sk_buff* skb) {
+         struct vlan_priority_tci_mapping* mp = dev->vlan_dev->egress_priority_map[(skb->priority & 0xF)];
+         while (mp) {
+                 if (mp->priority == skb->priority) {
+                         return mp->vlan_qos; /* This should already be shifted to mask correctly with
+                                               * the VLAN's TCI
+                                               */
+                 }
+                 mp = mp->next;
+         }
+         return 0;
+ }
+ 
+ static inline int vlan_dmi_equals(struct dev_mc_list *dmi1,
+                                   struct dev_mc_list *dmi2) {
+         return ((dmi1->dmi_addrlen == dmi2->dmi_addrlen) &&
+                 (memcmp(dmi1->dmi_addr, dmi2->dmi_addr, dmi1->dmi_addrlen) == 0));
+ }
+ 
+ static inline void vlan_destroy_mc_list(struct dev_mc_list *mc_list) {
+         struct dev_mc_list *dmi = mc_list, *next;
+ 
+         while(dmi) {
+                 next = dmi->next;
+                 kfree(dmi);
+                 dmi = next;
+         }
+ }
+ 
+ #endif /* __KERNEL__ */
+ 
+ /**  These are the IOCTLs relating to the /proc/net/vlan/ * files.
+  * Not all may be supported at this time, and some may be primarily
+  * used for testing and obtaining non-standard access to kernel
+  * devices.
+  */
+ 
+ #define VLAN_IOCTL 0x52 /* TODO:  Can I just make these up??? */
+ 
+ enum vlan_ioctls {
+         ADD_VLAN_IOCTL = (VLAN_IOCTL << 8),
+         DEL_VLAN_IOCTL,
+         SET_INGRESS_PRIORITY_IOCTL,
+         SET_EGRESS_PRIORITY_IOCTL,
+         GET_INGRESS_PRIORITY_IOCTL,
+         GET_EGRESS_PRIORITY_IOCTL,
+         SET_NAME_TYPE_IOCTL,
+         SET_VLAN_FLAG_IOCTL
+ }; /* vlan_ioctl enum */
+ 
+ enum vlan_name_types {
+         VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
+         VLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */
+         VLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */
+         VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */
+         VLAN_NAME_TYPE_HIGHEST
+ };
+ 
+ struct vlan_ioctl_args {
+         char dev1[24];
+ 
+         union {
+                 char dev2[24];
+                 int VID;
+                 unsigned long skb_priority;
+                 unsigned long name_type;
+                 unsigned long bind_type;
+                 unsigned long flag; /* Matches vlan_dev_info flags */
+         } u;
+ 
+         short vlan_qos;   /* Can also be flag-value, 1 to set, 0 to clear. */
+ };
+ 
+ 
+ #endif
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/include/linux/netdevice.h linux.dev/include/linux/netdevice.h
*** linux/include/linux/netdevice.h	Tue Jan  4 11:12:25 2000
--- linux.dev/include/linux/netdevice.h	Wed Oct 25 23:35:47 2000
***************
*** 38,43 ****
--- 38,50 ----
  #include <net/profile.h>
  #endif
+ 
+ #if (defined(CONFIG_VLAN_802_1Q))
+ struct vlan_dev_info;
+ #endif
+ 
  #endif
  
+ 
+ 
  /*
   *	For future expansion when we will have different priorities. 
***************
*** 52,56 ****
--- 59,67 ----
   
  #if !defined(CONFIG_AX25) && !defined(CONFIG_AX25_MODULE) && !defined(CONFIG_TR)
+ #if defined(CONFIG_VLAN_802_1Q)
+ #define LL_MAX_HEADER	36
+ #else
  #define LL_MAX_HEADER	32
+ #endif
  #else
  #if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
***************
*** 154,162 ****
  	struct hh_cache *hh_next;	/* Next entry			     */
  	atomic_t	hh_refcnt;	/* number of users                   */
! 	unsigned short  hh_type;	/* protocol identifier, f.e ETH_P_IP */
  	int		(*hh_output)(struct sk_buff *skb);
  	rwlock_t	hh_lock;
  	/* cached hardware header; allow for machine alignment needs.        */
! 	unsigned long	hh_data[16/sizeof(unsigned long)];
  };
  
--- 165,181 ----
  	struct hh_cache *hh_next;	/* Next entry			     */
  	atomic_t	hh_refcnt;	/* number of users                   */
! 	unsigned short  hh_type;	/* protocol identifier, f.e ETH_P_IP
!                                          *  NOTE:  For VLANs, this will be the
!                                          *  encapuslated type. --BLG
!                                          */
  	int		(*hh_output)(struct sk_buff *skb);
  	rwlock_t	hh_lock;
+ 
  	/* cached hardware header; allow for machine alignment needs.        */
! #ifdef 	CONFIG_VLAN_802_1Q /* we need 4 extra bytes for VLAN headers */
!  	unsigned long	hh_data[20/sizeof(unsigned long)];
! #else
!  	unsigned long	hh_data[16/sizeof(unsigned long)];
! #endif
  };
  
***************
*** 318,321 ****
--- 337,346 ----
  	struct dst_entry	*fastpath[NETDEV_FASTROUTE_HMASK+1];
  #endif
+ 
+ #ifdef CONFIG_VLAN_802_1Q
+    /*  Holds information that makes sense if this device is a VLAN device. */
+         struct vlan_dev_info* vlan_dev;
+ #endif
+ 
  };
  
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/Makefile linux.dev/net/802_1Q/Makefile
*** linux/net/802_1Q/Makefile	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/Makefile	Wed Oct 11 21:17:19 2000
***************
*** 0 ****
--- 1,26 ----
+ #
+ # Makefile for the Linux Ethernet layer.
+ #
+ # Note! Dependencies are done automagically by 'make dep', which also
+ # removes any old dependencies. DON'T put your own dependencies here
+ # unless it's something special (ie not a .c file).
+ #
+ # Note 2! The CFLAGS definition is now in the main makefile...
+ 
+ O_TARGET := 802_1Q.o
+ 
+ OBJS	:= vlan.o vlanproc.o vlan_dev.o
+ 
+ ifeq ($(CONFIG_SYSCTL),y)
+ OBJS += sysctl_net_vlan.o
+ endif
+ 
+ 
+ ifdef CONFIG_NET
+ O_OBJS	:= $(OBJS) $(OBJ2)
+ endif
+ 
+ include $(TOPDIR)/Rules.make
+ 
+ tar:
+ 	tar -cvf /dev/f1 .
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/sysctl_net_vlan.c linux.dev/net/802_1Q/sysctl_net_vlan.c
*** linux/net/802_1Q/sysctl_net_vlan.c	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/sysctl_net_vlan.c	Wed Oct 11 20:07:47 2000
***************
*** 0 ****
--- 1,18 ----
+ /* 
+  * sysctl_net_vlan.c: sysctl interface to net Ethernet VLAN subsystem.
+  *
+  * Begun Dec 20, 1998, Ben Greear
+  *
+  * TODO:  What, if anything, should this do??
+  */
+ 
+ #ifdef 	CONFIG_VLAN_802_1Q
+ 
+ #include <linux/mm.h>
+ #include <linux/sysctl.h>
+ 
+ ctl_table ether_vlan_table[] = {
+ 	{0}
+ };
+ 
+ #endif
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/vlan.c linux.dev/net/802_1Q/vlan.c
*** linux/net/802_1Q/vlan.c	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/vlan.c	Wed Oct 25 23:57:45 2000
***************
*** 0 ****
--- 1,447 ----
+ /*           -*- linux-c -*-
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Ethernet-type device handling.
+  *
+  * Version:	@(#)vlan.c	started	12/21/98
+  *                              
+  * Authors:	Ben Greear <greearb@candelatech.com>, <greearb@agcs.com>
+  * 
+  * Fixes:
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ 
+ #include <asm/uaccess.h> /* for copy_from_user */
+ #include <linux/module.h>
+ #include <linux/netdevice.h>
+ #include <linux/skbuff.h>
+ #include <net/datalink.h>
+ #include <linux/mm.h>
+ #include <linux/in.h>
+ #include <linux/init.h>
+ #include <net/p8022.h>
+ #include <net/arp.h>
+ 
+ #include <linux/if_vlan.h>
+ #include "vlan.h"
+ #include "vlanproc.h"
+ 
+ extern int register_netdevice(struct device *dev); /* found in dev.c */
+ extern int unregister_netdevice(struct device *dev); /* found in dev.c */
+ extern int dev_new_index(void); /* dev.c */
+ 
+ extern int eth_header_parse(struct sk_buff *skb, unsigned char *haddr); /* eth.c */
+ 
+ extern struct Qdisc noqueue_qdisc;
+ 
+ /* Global VLAN variables */
+ 
+ /* Our listing of VLAN group(s) */
+ struct vlan_group *p802_1Q_vlan_list = NULL;
+ 
+ static char vlan_fullname[] = "802.1Q VLAN Support";
+ static unsigned int vlan_version = 0;
+ static unsigned int vlan_release = 14;
+ static char vlan_copyright[] = "(c) 2000 Ben Greear (GPL)";
+ 
+ /** These may be changed at run-time through IOCTLs */
+ unsigned short vlan_name_type = 0; /* determines interface naming scheme */
+ unsigned long vlan_bad_proto_recvd = 0; /* Counter for how many NON-VLAN protos we've received on a VLAN. */
+ 
+ 
+ static struct packet_type vlan_packet_type = 
+ {
+         0,      /* MUTTER ntohs(ETH_P_802_1Q),*/
+         NULL,
+         vlan_dev_type_trans, /* VLAN receive method */
+         NULL,
+         NULL,
+ };
+ 
+ /* End of global variables definitions. */
+ 
+ #ifdef MODULE
+ 
+ /*
+  *	Kernel Loadable Module Entry Points
+  *
+  *	Module 'insert' entry point.
+  *	o print announcement
+  *	o initialize static data
+  *	o create /proc/net/vlan directory and static entries
+  *
+  *	Return:	0	Ok
+  *		< 0	error.
+  *	Context:	process
+  */
+ int init_module	(void) {
+         printk(VLAN_INF __FUNCTION__);
+ 
+         vlan_proto_init(NULL);
+         return 0;
+ }
+ 
+ /*
+  *	Module 'remove' entry point.
+  *	o delete /proc/net/router directory and static entries.
+  */ 
+ void cleanup_module (void) {
+         vlan_proto_cleanup(); // TODO: Define this so modules work.
+ }
+ 
+ #else
+ 
+ 
+ /** Non-module init entry point. */
+ __initfunc(void vlan_system_init(void)) {
+         printk(VLAN_INF __FUNCTION__);
+ 
+         /* protocol initialization */
+         vlan_proto_init(NULL);
+ 
+ }
+ #endif
+ 
+ /*
+  * Function vlan_proto_init (pro)
+  *
+  *    Initialize VLAN protocol layer, 
+  *
+  */
+ void vlan_proto_init(struct net_proto *pro) {
+ 
+         int err;
+         printk(VLAN_INF "%s v%u.%u %s\n",
+                vlan_fullname, vlan_version, vlan_release, vlan_copyright);
+ 
+         /* proc file system initialization */
+         err = vlan_proc_init();
+         if (err < 0) {
+                 printk(KERN_ERR __FUNCTION__
+                        "%s: can't create entry in proc filesystem!\n", VLAN_NAME);
+         }
+ 
+         /* network byte order!! */
+         vlan_packet_type.type = htons(ETH_P_802_1Q);
+         dev_add_pack(&vlan_packet_type);
+         printk(VLAN_INF "%s Initialization complete.\n", VLAN_NAME);
+ }
+ 
+ 
+ 
+ /**  Will search linearly for now, based on device index.  Could
+  * hash, or directly link, this some day. --Ben
+  */
+ struct vlan_group* vlan_find_group(int real_dev_ifindex) {
+         struct vlan_group* grp = NULL;
+ 
+         for (grp = p802_1Q_vlan_list;
+              ((grp != NULL) && (grp->real_dev_ifindex != real_dev_ifindex));
+              grp = grp->next) {
+ #ifdef VLAN_DEBUG
+                 printk(VLAN_DBG __FUNCTION__ ": grp_idx: %i  real_dev_idx: %i\n",
+                        grp->real_dev_ifindex, real_dev_ifindex);
+ #endif
+            ;
+         } /* for */
+          
+         return grp;
+ }
+ 
+ /*  Find the protocol handler.  Assumes VID < 0xFFF.
+  */
+ struct device *find_802_1Q_vlan_dev(struct device* real_dev, unsigned short VID) {
+ 
+         struct vlan_group* grp = vlan_find_group(real_dev->ifindex);
+ 
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": idx: %i  grp: %p\n", real_dev->ifindex, grp);
+ #endif
+ 
+         /*  When here, we have found the correct group, if it exists. */
+ 
+         if (grp) { /* then we found one */
+                 return grp->vlan_devices[VID]; /* return the vlan device */
+         }//if
+    
+         return NULL;
+ }/* find_802_1Q_vlan_dev */
+ 
+ 
+ 
+ int unregister_802_1Q_vlan_dev(int real_dev_ifindex, unsigned short vlan_id) {
+         struct vlan_group* grp;
+         struct device* dev = NULL;
+ 
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": VID: %i\n", vlan_id);
+ #endif
+    
+         /* sanity check */
+         if ((vlan_id >= 0xFFF) || (vlan_id <= 0)) {
+                 return -EINVAL;
+         }
+    
+         grp = vlan_find_group(real_dev_ifindex);
+         /*  When here, we have found the correct group, if it exists. */
+ 
+         if (grp) {
+                 dev = grp->vlan_devices[vlan_id];
+                 if (dev) {
+ 
+                         /* Remove proc entry */
+                         vlan_proc_rem_dev(dev);
+          
+                         /* take it out of our own structures */
+                         grp->vlan_devices[vlan_id] = NULL;
+ 
+                         /* Take it out of the global list of devices.
+                          *  NOTE:  This deletes dev, don't access it again!!
+                          */
+                         unregister_netdevice(dev);
+ 
+                 }/* if */
+         }/* if */
+         return 0;
+ }/* unregister vlan device */
+ 
+ 
+ 
+ int unregister_802_1Q_vlan_device(const char* vlan_IF_name) {
+         struct device* dev = NULL;
+ 
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": unregister VLAN by name, name -:%s:-\n",
+                vlan_IF_name);
+ #endif
+    
+         dev = dev_get(vlan_IF_name);
+ 
+         if (dev && dev->vlan_dev) {
+                 return unregister_802_1Q_vlan_dev(dev->vlan_dev->real_dev->ifindex,
+                                                   (unsigned short)(dev->vlan_dev->vlan_id));
+         }
+         else {
+ #ifdef VLAN_DEBUG
+                 printk(VLAN_DBG __FUNCTION__ ": WARNING: Could not find dev\n");
+ #endif
+                 return -EINVAL;
+         }
+ }/* unregister vlan device */
+ 
+ 
+ /*
+   TODO:  This for modules or something?? --BLG
+   
+   EXPORT_SYMBOL(register_802_1Q_vlan_device);
+   EXPORT_SYMBOL(unregister_802_1Q_vlan_device);
+ 
+ */
+ 
+ /*  Attach a VLAN device to a mac address (ie Ethernet Card).
+  *  Returns the device that was created, or NULL if there was
+  *  an error of some kind.
+  */
+ struct device *register_802_1Q_vlan_device(const char* eth_IF_name,
+                                            unsigned short VLAN_ID) {
+         struct vlan_group* grp;
+         struct device *new_dev;
+         struct device *real_dev; /* the ethernet device */
+         int malloc_size = 0;
+    
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": if_name -:%s:-  vid: %i\n",
+                eth_IF_name, VLAN_ID);
+ #endif
+    
+         /* find the device relating to eth_IF_name.
+     * TODO:  Make sure it's an ethernet device. */
+         real_dev = dev_get(eth_IF_name);
+ 
+         if (real_dev != NULL) {
+                 /* printk(KERN_ALERT "Found real_dev"); */
+             
+                 if ((VLAN_ID > 0) && (VLAN_ID < 0xFFF)) {
+ 
+                         /* printk(KERN_ALERT "VID is in range"); */
+ 
+                         if (find_802_1Q_vlan_dev(real_dev, VLAN_ID)) {
+                                 /* was already registered. */
+                                 printk(VLAN_DBG __FUNCTION__ ": ALREADY had VLAN registered\n");
+                                 return NULL;
+                         }
+ 
+                         malloc_size = (sizeof(struct device));
+ 
+                         new_dev = (struct device*) kmalloc(malloc_size, GFP_KERNEL);
+                         VLAN_MEM_DBG("device malloc, addr: %p  size: %i\n", new_dev, malloc_size);
+          
+                         if (new_dev != NULL) {
+                                 /* printk(KERN_ALERT "Got a new device.."); */
+             
+                                 memset(new_dev, 0, malloc_size); /* zero everything out */
+ 
+                                 /* set us up to not use a Qdisc, as the underlying Hardware device
+                                  * can do all the queueing we could want.
+                                  */
+                                 new_dev->qdisc_sleeping = &noqueue_qdisc;
+             
+                                 /* Gotta set up the fields for the device. */
+                                 new_dev->name = (char*)(kmalloc(IFNAMSIZ + 1, GFP_KERNEL));
+                                 VLAN_MEM_DBG("new_dev->name malloc, addr: %p  size: %i\n", new_dev->name, IFNAMSIZ + 1);
+             
+                                 if (new_dev->name) {
+                                         memset(new_dev->name, 0, IFNAMSIZ + 1); /* zero everything out */
+                                 }
+                                 else {
+                                         kfree(new_dev);
+                                         VLAN_FMEM_DBG("new_dev free, addr: %p\n", new_dev);
+                                         return NULL;
+                                 }
+ 
+                                 if (vlan_name_type == VLAN_NAME_TYPE_RAW_PLUS_VID) {
+                                         /* name will look like:  eth1.0005 */
+                                         sprintf(new_dev->name, "%s.%.4i", real_dev->name, VLAN_ID);
+                                 }
+                                 else if (vlan_name_type == VLAN_NAME_TYPE_PLUS_VID_NO_PAD) {
+                                         /* Put our vlan.VID in the name.  Name will look like:  vlan5 */
+                                         sprintf(new_dev->name, "vlan%i", VLAN_ID);
+                                 }
+                                 else if (vlan_name_type == VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD) {
+                                         /* Put our vlan.VID in the name.  Name will look like:  eth0.5 */
+                                         sprintf(new_dev->name, "%s.%i", real_dev->name, VLAN_ID);
+                                 }
+                                 else { /* (vlan_name_type == VLAN_NAME_TYPE_PLUS_VID) { */
+                                         /* Put our vlan.VID in the name.  Name will look like:  vlan0005 */
+                                         /* default case */
+                                         sprintf(new_dev->name, "vlan%.4i", VLAN_ID);
+                                 }
+             
+             
+ #ifdef VLAN_DEBUG
+                                 printk(VLAN_DBG "Allocated new name -:%s:-\n", new_dev->name);
+ #endif
+                                 /* set up method calls */
+                                 new_dev->init = vlan_dev_init;
+                                 new_dev->destructor = vlan_dev_destruct;
+             
+                                 /* new_dev->ifindex = 0;  it will be set when added to
+                                  * the global list.
+                                  * iflink is set as well. */
+             
+                                 new_dev->get_stats = vlan_dev_get_stats;
+             
+                                 /* IFF_BROADCAST|IFF_MULTICAST; ??? */
+                                 new_dev->flags = real_dev->flags;
+                                 new_dev->flags &= ~IFF_UP;
+             
+                                 /* need 4 bytes for extra VLAN header info, hope
+                                  * underlying device can handle it. */
+                                 new_dev->mtu = real_dev->mtu;
+             
+                                 new_dev->type = real_dev->type; /* TODO: is this true? */
+ 
+                                 /* Regular ethernet + 4 bytes (18 total). */
+                                 new_dev->hard_header_len = VLAN_ETH_HLEN;
+ 
+                                 new_dev->priv = kmalloc(sizeof(struct net_device_stats),
+                                                         GFP_KERNEL);
+                                 VLAN_MEM_DBG("new_dev->priv malloc, addr: %p  size: %i\n", new_dev->priv,
+                                              sizeof(struct net_device_stats));
+             
+                                 if (new_dev->priv) {
+                                         memset(new_dev->priv, 0, sizeof(struct net_device_stats));
+                                 }//if
+ 
+                                 memcpy(new_dev->broadcast, real_dev->broadcast, real_dev->addr_len);
+                                 memcpy(new_dev->dev_addr, real_dev->dev_addr, real_dev->addr_len);
+                                 new_dev->addr_len = real_dev->addr_len;
+ 
+                                 new_dev->open = vlan_dev_open;
+                                 new_dev->stop = vlan_dev_stop;
+                                 new_dev->hard_header = vlan_dev_hard_header;
+                                 /*new_dev->hard_header_cache = vlan_header_cache;*/
+                                 /*new_dev->header_cache_update = vlan_header_cache_update;*/
+                                 new_dev->hard_start_xmit = vlan_dev_hard_start_xmit;
+                                 new_dev->rebuild_header = vlan_dev_rebuild_header;
+                                 new_dev->hard_header_parse = eth_header_parse; /* trivial. */
+                                 new_dev->set_mac_address = vlan_dev_set_mac_address;
+                                 new_dev->set_multicast_list = vlan_dev_set_multicast_list;
+ 
+                                 new_dev->vlan_dev = (struct vlan_dev_info*) kmalloc(sizeof(struct vlan_dev_info),
+                                                                                     GFP_KERNEL);
+                                 VLAN_MEM_DBG("new_dev->vlan_dev malloc, addr: %p  size: %i\n", new_dev->vlan_dev,
+                                              sizeof(struct vlan_dev_info));
+                                 if (new_dev->vlan_dev == NULL) {
+                                         kfree(new_dev->priv);
+                                         VLAN_FMEM_DBG("new_dev->priv free, addr: %p\n", new_dev->priv);
+                                         kfree(new_dev->name);
+                                         VLAN_FMEM_DBG("new_dev->name free, addr: %p\n", new_dev->name);
+                                         kfree(new_dev);
+                                         VLAN_FMEM_DBG("new_dev free, addr: %p\n", new_dev);
+                                         return NULL;
+                                 }
+                                 else {
+                                         /* Initialize it. */
+                                         memset(new_dev->vlan_dev, 0, sizeof(struct vlan_dev_info));
+                
+                                         new_dev->vlan_dev->vlan_id = VLAN_ID; /* 1 through 0xFFF */
+                                         /* TODO: have to be careful deleting real devices now. */
+                                         new_dev->vlan_dev->real_dev = real_dev;
+ 
+                                         memset(&(new_dev->vlan_dev->dent), 0, sizeof(struct proc_dir_entry));
+                                 }
+             
+                                 /* So, got the sucker initialized, now lets place it into our local
+                                  * structure.
+                                  */
+ 
+                                 grp = vlan_find_group(real_dev->ifindex);
+ 
+                                 /*  When here, we have found the correct group, if it exists. */
+ 
+                                 if (!grp) { /* need to add a new group */
+                                         /* printk(VLAN_DBG "VLAN REGISTER: "
+                                            "Need to add new vlan group.\n");*/
+ 
+                                         grp = kmalloc(sizeof(struct vlan_group), GFP_KERNEL);
+                                         VLAN_MEM_DBG("grp malloc, addr: %p  size: %i\n", grp, sizeof(struct vlan_group));
+ 
+                                         if (grp) {
+                                                 printk(KERN_ALERT "VLAN REGISTER:  Allocated new group, idx: %i\n",
+                                                        real_dev->ifindex);
+                                                 memset(grp, 0, sizeof(struct vlan_group));
+                                                 grp->real_dev_ifindex = real_dev->ifindex;
+                                                 grp->next = p802_1Q_vlan_list;
+                                                 p802_1Q_vlan_list = grp;
+                                         }
+                                         else {
+                                                 kfree(new_dev->name);
+                                                 VLAN_FMEM_DBG("new_dev->name free, addr: %p\n", new_dev->name);
+                                                 kfree(new_dev->priv);
+                                                 VLAN_FMEM_DBG("new_dev->priv free, addr: %p\n", new_dev->priv);
+                                                 kfree(new_dev);
+                                                 VLAN_FMEM_DBG("new_dev free, addr: %p\n", new_dev);
+                                                 return NULL;
+                                         }
+                                 }/* if */
+             
+                                 grp->vlan_devices[VLAN_ID] = new_dev;
+ 
+                                 /*  Now, add it to the global list of devices. */
+                                 /* printk(KERN_ALERT "Registering new device."); */
+                                 register_netdevice(new_dev);
+                                 vlan_proc_add_dev(new_dev); /* create it's proc entry */
+                                 return new_dev;
+                         }
+                 }//if
+         }//if
+ 
+         return NULL;
+ }/* register (create) VLAN device */
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/vlan.h linux.dev/net/802_1Q/vlan.h
*** linux/net/802_1Q/vlan.h	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/vlan.h	Thu Oct 26 00:30:40 2000
***************
*** 0 ****
--- 1,44 ----
+ #ifndef __BEN_VLAN_802_1Q_INC__
+ #define __BEN_VLAN_802_1Q_INC__
+ 
+ #include <linux/if_vlan.h>
+ 
+ /* If this is undefined, the name will look like:  vlan0005 */
+ /* #define USE_RAW_IN_NAME   Use this one if you like it:  eth.0005 */
+ 
+ /*  Uncomment this if you want debug traces to be shown. */
+ /* #define VLAN_DEBUG */
+ 
+ #define VLAN_ERR KERN_ERR
+ #define VLAN_INF KERN_ALERT
+ #define VLAN_DBG KERN_DEBUG /* change these... to debug, having a hard time
+                              * changing the log level at run-time..for some reason.
+                              */
+ 
+ /*
+ 
+ These I use for memory debugging.  I feared a leak at one time, but
+ I never found it..and the problem seems to have dissappeared.  Still,
+ I'll bet they might prove useful again... --Ben
+ 
+ #define VLAN_MEM_DBG(x, y, z) printk(VLAN_DBG __FUNCTION__ ":  "  x, y, z);
+ #define VLAN_FMEM_DBG(x, y) printk(VLAN_DBG __FUNCTION__  ":  " x, y);
+ */
+ 
+ /* This way they don't do anything! */ 
+ #define VLAN_MEM_DBG(x, y, z)
+ #define VLAN_FMEM_DBG(x, y)
+ 
+ 
+ extern unsigned short vlan_name_type;
+ extern unsigned long vlan_bad_proto_recvd; /* Counter for how many NON-VLAN protos we've received on a VLAN. */
+ 
+ /* Add some headers for the public VLAN methods. */
+ int unregister_802_1Q_vlan_device(const char* vlan_IF_name);
+ struct device *register_802_1Q_vlan_device(const char* eth_IF_name,
+                                            unsigned short VID);
+ 
+ void vlan_system_init(void);
+ void vlan_proto_init(struct net_proto *pro);
+ 
+ #endif
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/vlan_dev.c linux.dev/net/802_1Q/vlan_dev.c
*** linux/net/802_1Q/vlan_dev.c	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/vlan_dev.c	Wed Oct 25 23:57:45 2000
***************
*** 0 ****
--- 1,740 ----
+ /* -*- linux-c -*-
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Ethernet-type device handling.
+  *
+  * Version:	@(#)vlan_dev.c	Started	3/29/99
+  *
+  * Authors:	Ben Greear <greearb@candelatech.com>, <greearb@agcs.com>
+  * 
+  * Fixes:
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ 
+ #include <asm/uaccess.h> /* for copy_from_user */
+ #include <linux/module.h>
+ #include <linux/netdevice.h>
+ #include <linux/skbuff.h>
+ #include <net/datalink.h>
+ #include <linux/mm.h>
+ #include <linux/in.h>
+ #include <linux/init.h>
+ #include <net/p8022.h>
+ #include <net/arp.h>
+ #include "vlan.h"
+ #include "vlanproc.h"
+ #include <linux/if_vlan.h>
+ #include <net/ip.h>
+ #include <asm/checksum.h>
+ 
+ 
+ struct net_device_stats* vlan_dev_get_stats(struct device* dev) {
+         return (struct net_device_stats*)(dev->priv);
+ }
+ 
+ 
+ /*
+  *	Rebuild the Ethernet MAC header. This is called after an ARP
+  *	(or in future other address resolution) has completed on this
+  *	sk_buff. We now let ARP fill in the other fields.
+  *
+  *	This routine CANNOT use cached dst->neigh!
+  *	Really, it is used only when dst->neigh is wrong.
+  *
+  * TODO:  This needs a checkup, I'm ignorant here. --BLG
+  */
+ int vlan_dev_rebuild_header(struct sk_buff *skb) {
+ 
+         struct device *dev = skb->dev;
+         struct vlan_ethhdr *veth = (struct vlan_ethhdr*)(skb->data);
+ 
+         switch (veth->h_vlan_encapsulated_proto)
+         {
+ #ifdef CONFIG_INET
+         case __constant_htons(ETH_P_IP):
+ 
+                 /* TODO:  Confirm this will work with VLAN headers... */
+                 return arp_find(veth->h_dest, skb);
+ #endif	
+         default:
+                 printk(VLAN_DBG
+                        "%s: unable to resolve type %X addresses.\n", 
+                        dev->name, (int)veth->h_vlan_encapsulated_proto);
+          
+                 memcpy(veth->h_source, dev->dev_addr, ETH_ALEN);
+                 break;
+         }/* switch */
+ 
+         return 0;
+ }/* vlan_dev_rebuild_header */
+ 
+ 
+ 
+ /*
+  *	Determine the packet's protocol ID. The rule here is that we 
+  *	assume 802.3 if the type field is short enough to be a length.
+  *	This is normal practice and works for any 'now in use' protocol.
+  *
+  *  Also, at this point we assume that we ARE dealing exclusively with
+  *  VLAN packets, or packets that should be made into VLAN packets based
+  *  on a default VLAN ID.
+  *
+  *  NOTE:  Should be similar to ethernet/eth.c.
+  *
+  *  SANITY NOTE:  This method is called when a packet is moving up the stack
+  *                towards userland.  To get here, it would have already passed
+  *                through the ethernet/eth.c eth_type_trans() method.
+  */
+ int vlan_dev_type_trans(struct sk_buff *skb, struct device *dev,
+                         struct packet_type* ptype) {
+         unsigned char* rawp = NULL;
+         struct vlan_ethhdr *veth = (struct vlan_ethhdr*)(skb->mac.ethernet);
+         unsigned short vid = 0;
+         struct net_device_stats* stats;
+    
+         /* Do we have a VLAN packet?  If not, then throw it away, after printing an error.
+          *
+          */
+         if (veth->h_vlan_proto != __constant_htons(ETH_P_802_1Q)) {
+                 printk(VLAN_INF __FUNCTION__ ": VLAN device received NON-VLAN protocol: %hx\n", htons(veth->h_vlan_proto));
+                 vlan_bad_proto_recvd++;
+                 kfree_skb(skb);
+                 return -EINVAL;
+         }
+         else {
+                 vid = ((unsigned short)(ntohs(veth->h_vlan_TCI)) & 0xFFF);
+         }
+ 
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": skb: %p vlan_id: %hx dev: %s, encap_proto: %hx\n",
+                skb, vid, dev->name, veth->h_vlan_encapsulated_proto);
+ #endif
+    
+         /*  Ok, we will find the correct VLAN device, strip the header,
+             and then go on as usual.
+         */
+         
+         /* we have 12 bits of vlan ID. */
+         /* If it's NULL, we will tag the skb to be junked below */
+         skb->dev = find_802_1Q_vlan_dev(dev, vid);
+ 
+         if (!skb->dev) {
+ #ifdef VLAN_DEBUG
+                 printk(VLAN_DBG __FUNCTION__ ": ERROR:  No device for VID: %i on dev: %s [%i]\n",
+                        (unsigned int)(vid), dev->name, dev->ifindex);
+ #endif
+                 kfree_skb(skb);
+                 return -1;
+         }
+ 
+         stats = (struct net_device_stats*)(skb->dev->priv);
+ 
+         /*
+          * Deal with ingress priority mapping.
+          */
+         skb->priority = skb->dev->vlan_dev->ingress_priority_map[(ntohs(veth->h_vlan_TCI) >> 13) & 0x7];
+    
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": priority: %lu  for TCI: %hu (hbo) on vlan_dev: %s\n",
+                (unsigned long)(skb->priority), ntohs(veth->h_vlan_TCI), skb->dev->name);
+ #endif
+ 
+         /* Bump the rx counters for the VLAN device. */
+         stats->rx_packets++;
+         stats->rx_bytes += skb->len;
+       
+         /* NOTE: The underlying device SHOULD NOT PULL THE MAC BYTES OFF.
+            (it doesn't seem to.)
+         */
+         skb_pull(skb, VLAN_ETH_HLEN); /* take off the VLAN header */
+    
+    
+         /*  VLAN and regular Ethernet headers have the addresses in the same place.
+          *  TODO:  Add code to deal with VLAN control packets?? --BLG
+          *         Is there such a thing??
+          */
+         if (*(veth->h_dest) & 1) {
+                 stats->multicast++;
+                 if (memcmp(veth->h_dest, dev->broadcast, ETH_ALEN) == 0)
+                         skb->pkt_type = PACKET_BROADCAST;
+                 else
+                         skb->pkt_type = PACKET_MULTICAST;
+         }
+ 	
+         /*
+          *	This ALLMULTI check should be redundant by 1.4
+          *	so don't forget to remove it.
+          *
+          *	Seems, you forgot to remove it. All silly devices
+          *	seems to set IFF_PROMISC.
+          */
+    
+         else if (dev->flags & (IFF_PROMISC/*|IFF_ALLMULTI*/)) {
+                 if (memcmp(veth->h_dest, dev->dev_addr, ETH_ALEN) != 0)
+                         skb->pkt_type = PACKET_OTHERHOST;
+         }
+ 
+         /*  Was a VLAN packet, grab the encapsulated protocol, which the layer
+          * three protocols care about.
+          */
+         if (ntohs(veth->h_vlan_encapsulated_proto) >= 1536) {
+            
+            skb->protocol = veth->h_vlan_encapsulated_proto;
+            /* place it back on the queue to be handled by true layer 3 protocols.
+             */
+            
+            /* See if we are configured to re-write the VLAN header to make it look like
+             * ethernet...
+             */
+            if (skb->dev->vlan_dev->flags & 1) {
+                    /* Lifted from Gleb's VLAN code... */
+                    memmove(skb->data - (VLAN_ETH_HLEN - 4), skb->data - VLAN_ETH_HLEN, 12);
+                    skb->mac.raw += 4;
+            }
+            netif_rx(skb);
+            return 0;
+         }
+ 
+         rawp = skb->data;
+ 	
+         /*
+          *	This is a magic hack to spot IPX packets. Older Novell breaks
+          *	the protocol design and runs IPX over 802.3 without an 802.2 LLC
+          *	layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This
+          *	won't work for fault tolerant netware but does for the rest.
+          */
+         if (*(unsigned short *)rawp == 0xFFFF) {
+                 skb->protocol = __constant_htons(ETH_P_802_3);
+                 /* place it back on the queue to be handled by true layer 3 protocols.
+                  */
+       
+                 /* See if we are configured to re-write the VLAN header to make it look like
+                  * ethernet...
+                  */
+                 if (skb->dev->vlan_dev->flags & 1) {
+                         /* Lifted from Gleb's VLAN code... */
+                         memmove(skb->data - (VLAN_ETH_HLEN - 4), skb->data - VLAN_ETH_HLEN, 12);
+                         skb->mac.raw += 4;
+                 }
+                 netif_rx(skb);
+                 return 0;
+         }
+ 		
+         /*
+          *	Real 802.2 LLC
+          */
+         skb->protocol = __constant_htons(ETH_P_802_2);
+         /* place it back on the queue to be handled by upper layer protocols.
+          */
+ 
+         /* See if we are configured to re-write the VLAN header to make it look like
+          * ethernet...
+          */
+         if (skb->dev->vlan_dev->flags & 1) {
+                 /* Lifted from Gleb's VLAN code... */
+                 memmove(skb->data - (VLAN_ETH_HLEN - 4), skb->data - VLAN_ETH_HLEN, 12);
+                 skb->mac.raw += 4;
+         }
+         netif_rx(skb);
+         return 0;
+ }
+ 
+ 
+ /*
+  *	 Create the Ethernet VLAN MAC header for an arbitrary protocol layer 
+  *
+  *	saddr=NULL	means use device source address
+  *	daddr=NULL	means leave destination address (eg unresolved arp)
+  *
+  *  This is called when the SKB is moving down the stack towards the
+  *  physical devices.
+  */
+ int vlan_dev_hard_header(struct sk_buff *skb, struct device *dev,
+                          unsigned short type, void *daddr, void *saddr,
+                          unsigned len) {
+         struct vlan_ethhdr *veth;
+         unsigned short veth_TCI = 0;
+         
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": skb: %p type: %hx len: %x vlan_id: %hx, daddr: %p\n",
+                skb, type, len, dev->vlan_dev->vlan_id, daddr);
+ #endif
+    
+         veth = (struct vlan_ethhdr*)skb_push(skb, VLAN_ETH_HLEN);
+ 
+         /* build the four bytes that make this a VLAN header. */
+ 
+         /* first, the ethernet type */
+         veth->h_vlan_proto = __constant_htons(ETH_P_802_1Q);
+ 
+         /* Now, construct the second two bytes. This field looks something
+          * like:
+          * usr_priority: 3 bits  (high bits)
+          * CFI           1 bit
+          * VLAN ID       12 bits (low bits)
+          *
+          */
+         veth_TCI = dev->vlan_dev->vlan_id;
+         veth_TCI |= vlan_dev_get_egress_qos_mask(dev, skb);
+    
+         veth->h_vlan_TCI = htons(veth_TCI);
+            
+         /* Rest should be the same as a normal header. */
+         /* 
+          *  Set the protocol type. For a packet of type ETH_P_802_3 we put the length
+          *  in here instead. It is up to the 802.2 layer to carry protocol information.
+          *
+          */
+ 
+         if (type != ETH_P_802_3) 
+                 veth->h_vlan_encapsulated_proto = htons(type);
+         else
+                 veth->h_vlan_encapsulated_proto = htons(len);
+ 
+         /*
+          *	Set the source hardware address. 
+          */
+            
+         if (saddr)
+                 memcpy(veth->h_source, saddr, ETH_ALEN);
+         else
+                 memcpy(veth->h_source, dev->dev_addr, ETH_ALEN);
+    
+         /*
+          *	Anyway, the loopback-device should never use this function... 
+          *   This is especially true with VLAN's. --BLG
+          */
+    
+         if (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {
+                 memset(veth->h_dest, 0, ETH_ALEN);
+                 return (VLAN_ETH_HLEN); /* was: dev->hard_header_len */
+         }
+    
+         if (daddr) {
+                 memcpy(veth->h_dest, daddr, ETH_ALEN);
+                 return (VLAN_ETH_HLEN); /* was: dev->hard_header_len */
+         }
+    
+         return -(VLAN_ETH_HLEN); /* was: dev->hard_header_len */
+    
+ } /* vlan_hard_header, put on the VLAN hardware header */
+ 
+ 
+ int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct device *dev) {
+         struct net_device_stats* stats = (struct net_device_stats*)(dev->priv);
+         struct vlan_ethhdr *veth = (struct vlan_ethhdr*)(skb->data);
+         
+                 /* Handle non-VLAN frames if they are sent to us, for example by DHCP. */
+         if (veth->h_vlan_proto != __constant_htons(ETH_P_802_1Q)) {
+                 /* This is not a VLAN frame...but we can fix that! */
+                 unsigned short veth_TCI = 0;
+                 dev->vlan_dev->cnt_encap_on_xmit++;
+                 
+                 if (skb_headroom(skb) < 4) {
+                         struct sk_buff* sk_tmp = skb;
+                         skb = skb_realloc_headroom(sk_tmp, 4);
+                         kfree_skb(sk_tmp);
+                         if (skb == NULL) {
+                                 stats->tx_dropped++;
+                                 kfree_skb(sk_tmp);
+                                 return -ENOMEM;
+                         }
+                         dev->vlan_dev->cnt_inc_headroom_on_tx++;
+                 }
+                 else {
+                         if( !(skb = skb_unshare(skb, GFP_ATOMIC)) ) {
+                                 printk(KERN_ERR "vlan: failed to unshare skbuff\n");
+                                 stats->tx_dropped++;
+                                 return -ENOMEM;
+                         }
+                 }
+                 veth = (struct vlan_ethhdr*)skb_push(skb, 4);
+ 
+                 /* Move the mac addresses to the beginning of the new header. */
+                 memmove(skb->data, skb->data + 4, 12);
+ 
+                 /* first, the ethernet type */
+                 veth->h_vlan_proto = __constant_htons(ETH_P_802_1Q);
+ 
+                 /* Now, construct the second two bytes. This field looks something
+                  * like:
+                  * usr_priority: 3 bits  (high bits)
+                  * CFI           1 bit
+                  * VLAN ID       12 bits (low bits)
+                  *
+                  */
+                 veth_TCI = dev->vlan_dev->vlan_id;
+                 veth_TCI |= vlan_dev_get_egress_qos_mask(dev, skb);
+    
+                 veth->h_vlan_TCI = htons(veth_TCI);
+         }/* If we needed to encapsulate the frame */
+ 
+         skb->dev = dev->vlan_dev->real_dev;
+ 
+ 
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": about to send skb: %p  to dev: %s\n", skb, skb->dev->name);
+ #endif
+ 
+         dev_queue_xmit(skb);
+         stats->tx_packets++; /* for statics only */
+         stats->tx_bytes += skb->len;
+         return 0;
+ }/* vlan_dev_hard_start_xmit */
+ 
+ 
+ int vlan_dev_change_mtu(struct device *dev, int new_mtu) {
+         /* TODO: gotta make sure the underlying layer can handle it,
+          * maybe an IFF_VLAN_CAPABLE flag for devices?
+     */
+ 
+         dev->mtu = new_mtu;
+         return new_mtu;
+ }
+ 
+ int vlan_dev_open(struct device* dev) {
+         dev->flags |= IFF_UP;
+         return 0;
+ }
+ 
+ int vlan_dev_stop(struct device* dev) {
+         dev->flags &= ~IFF_UP;
+         return 0;
+ }
+ 
+ int vlan_dev_init(struct device* dev) {
+         /* TODO:  figure this out, maybe do nothing?? */
+         return 0;
+ }
+ 
+ void vlan_dev_destruct(struct device* dev) {
+         kfree(dev->name);
+         VLAN_FMEM_DBG("dev->name free, addr: %p\n", dev->name);
+         dev->name = NULL; /* better safe than hosed */
+    
+         kfree(dev->priv);
+         VLAN_FMEM_DBG("dev->priv free, addr: %p\n", dev->priv);
+         dev->priv = NULL;
+    
+         kfree(dev->vlan_dev);
+         VLAN_FMEM_DBG("dev->vlan_dev free, addr: %p\n", dev->vlan_dev);
+         dev->vlan_dev = NULL;
+ 
+         kfree(dev);
+         VLAN_FMEM_DBG("device free, addr: %p\n", dev);
+         dev = NULL;
+ 
+         return;
+ }
+ 
+ 
+ /* TODO:  Not to sure if the VLAN stuff works here.  Need to understand
+  * this better. --BLG
+  */
+ /*
+ int vlan_dev_header_cache(struct neighbour *neigh, struct hh_cache *hh) {
+    unsigned short type = hh->hh_type;
+    struct vlan_ethhdr *veth = (struct vlan_ethhdr*)(((u8*)hh->hh_data) + 2);
+    struct device *dev = neigh->dev;
+ 
+    if (type == __constant_htons(ETH_P_802_3)) {
+       return -1;
+    }
+ 
+    veth->h_vlan_proto = __constant_htons(ETH_P_802_1Q);
+    memcpy(veth->h_source, dev->dev_addr, ETH_ALEN);
+    memcpy(veth->h_dest, neigh->ha, ETH_ALEN);
+       
+    * VLAN specific attributes. *
+    veth->h_vlan_TCI = htons(dev->VLAN_id); * TODO:  Add priority control (high 3 bits.) * 
+    veth->h_vlan_encapsulated_proto = type; * should already be in network order *
+         
+    return 0;
+ }
+ */
+ 
+ /*
+  * Called by Address Resolution module to notify changes in address.
+  */
+ /*
+ void vlan_dev_header_cache_update(struct hh_cache *hh, struct device *dev,
+                                   unsigned char * haddr) {
+    memcpy(((u8*)hh->hh_data) + 2, haddr, VLAN_ETH_HLEN);
+ }
+ */
+ 
+ #ifndef CONFIG_IP_ROUTER
+ 
+ /*
+  *	Copy from an ethernet device memory space to an sk_buff while
+  *      checksumming if IP
+  *
+  *  TODO:  Find out who calls this:  This was lifted from eth.c, and
+  *         was called eth_copy_and_sum. --BLG
+  */
+ 
+ void vlan_dev_copy_and_sum(struct sk_buff *dest, unsigned char *src,
+                            int length, int base) {
+         struct vlan_ethhdr* veth;
+         struct iphdr *iph;
+         int ip_length;
+    
+         veth = (struct vlan_ethhdr*)(src);
+    
+         /*  This grabs the VLAN part of the header too. */
+         if (veth->h_vlan_encapsulated_proto != __constant_htons(ETH_P_IP)) {
+                 memcpy(dest->data, src, length);
+                 return;
+         }
+       
+         /*
+     * We have to watch for padded packets. The csum doesn't include the
+     * padding, and there is no point in copying the padding anyway.
+     * We have to use the smaller of length and ip_length because it
+     * can happen that ip_length > length.
+     */
+       
+    /* ethernet is always >= 34 */
+         memcpy(dest->data, src, sizeof(struct iphdr) + VLAN_ETH_HLEN);
+       
+         length -= sizeof(struct iphdr) + VLAN_ETH_HLEN;
+         iph = (struct iphdr*)(src + VLAN_ETH_HLEN);
+         ip_length = ntohs(iph->tot_len) - sizeof(struct iphdr);
+    
+    /* Also watch out for bogons - min IP size is 8 (rfc-1042) */
+         if ((ip_length <= length) && (ip_length > 7))
+                 length=ip_length;
+    
+         dest->csum = csum_partial_copy(src + sizeof(struct iphdr) + VLAN_ETH_HLEN,
+                                        dest->data + sizeof(struct iphdr) + VLAN_ETH_HLEN,
+                                        length, base);
+         dest->ip_summed=1;
+ 
+ } /* vlan_copy_and_sum */
+ 
+ #endif //! CONFIG_IP_ROUTER
+ 
+ 
+ int vlan_dev_set_ingress_priority(char* dev_name, __u32 skb_prio, short vlan_prio) {
+         struct device* dev = dev_get(dev_name);
+    
+         if (dev) {
+                 if (dev->vlan_dev) { /* can't put a dflt ID on a vlan device */
+                         /* see if a priority mapping exists.. */
+                         dev->vlan_dev->ingress_priority_map[vlan_prio & 0x7] = skb_prio;
+                         return 0;
+                 }
+         }
+         return -EINVAL;
+ }
+ 
+ int vlan_dev_set_egress_priority(char* dev_name, __u32 skb_prio, short vlan_prio) {
+         struct device* dev = dev_get(dev_name);
+         struct vlan_priority_tci_mapping* mp = NULL;
+         struct vlan_priority_tci_mapping* np;
+    
+         if (dev) {
+                 if (dev->vlan_dev) { /* can't put a dflt ID on a vlan device */
+                         /* see if a priority mapping exists.. */
+                         mp = dev->vlan_dev->egress_priority_map[skb_prio & 0xF];
+                         while (mp) {
+                                 if (mp->priority == skb_prio) {
+                                         mp->vlan_qos = ((vlan_prio << 13) & 0xE000);
+                                         return 0;
+                                 }
+                         }
+                         /* create a new mapping then. */
+                         mp = dev->vlan_dev->egress_priority_map[skb_prio & 0xF];
+                         np = kmalloc(sizeof(struct vlan_priority_tci_mapping), GFP_KERNEL);
+                         if (np) {
+                                 np->next = mp;
+                                 np->priority = skb_prio;
+                                 np->vlan_qos = ((vlan_prio << 13) & 0xE000);
+                                 dev->vlan_dev->egress_priority_map[skb_prio & 0xF] = np;
+                                 return 0;
+                         }
+                         else {
+                                 return -ENOBUFS;
+                         }
+                 }
+         }
+         return -EINVAL;
+ }
+ 
+ /* Flags are defined in the vlan_dev_info class in include/linux/if_vlan.h file. */
+ int vlan_dev_set_vlan_flag(char* dev_name, __u32 flag, short flag_val) {
+         struct device* dev = dev_get(dev_name);
+    
+         if (dev) {
+                 if (dev->vlan_dev) {
+                         /* verify flag is supported */
+                         if (flag == 1) {
+                                 if (flag_val) {
+                                         dev->vlan_dev->flags |= 1;
+                                 }
+                                 else {
+                                         dev->vlan_dev->flags &= ~1;
+                                 }
+                                 return 0;
+                         }
+                         else {
+                                 return -EINVAL;
+                         }
+                 }/* if it's a vlan device */
+         }/* if we found the device */
+         return -EINVAL;
+ }
+ 
+ 
+ int vlan_dev_set_mac_address(struct device *dev, void* addr) {
+         int i;
+         printk("%s: Setting MAC address to ", dev->name);
+         for (i = 0; i < 6; i++)
+                 printk(" %2.2x", dev->dev_addr[i] = ((unsigned char *)addr)[i]);
+         printk(".\n");
+         printk("  Make sure the underlying device is in promiscious mode!\n");
+ 
+         /* Copy the address. */
+         memcpy(dev->dev_addr, addr, 6);
+ 
+         return 0;
+ }
+ 
+ 
+ /** Taken from Gleb + Lennert's VLAN code, and modified... */
+ void vlan_dev_set_multicast_list(struct device *vlan_dev) {
+         struct dev_mc_list *dmi;
+         struct device *real_dev;
+         int inc;
+ 
+         if (vlan_dev && vlan_dev->vlan_dev) {
+                 /* Then it's a real vlan device, as far as we can tell.. */
+                 real_dev = vlan_dev->vlan_dev->real_dev;
+ 
+                 /* compare the current promiscuity to the last promisc we had.. */
+                 inc = vlan_dev->promiscuity - vlan_dev->vlan_dev->old_promiscuity;
+    
+                 if (inc) {
+                         printk(KERN_INFO "vlan: dev_set_promiscuity(master, %d)\n", inc);
+                         dev_set_promiscuity(real_dev, inc); /* found in dev.c */
+                         vlan_dev->vlan_dev->old_promiscuity = vlan_dev->promiscuity;
+                 }
+    
+                 inc = vlan_dev->allmulti - vlan_dev->vlan_dev->old_allmulti;
+    
+                 if (inc) {
+                         printk(KERN_INFO "vlan: dev_set_allmulti(master, %d)\n", inc);
+                         dev_set_allmulti(real_dev, inc); /* dev.c */
+                         vlan_dev->vlan_dev->old_allmulti = vlan_dev->allmulti;
+                 }
+    
+                 /* looking for addresses to add to master's list */
+                 for (dmi = vlan_dev->mc_list; dmi!=NULL; dmi=dmi->next) {
+                         if (vlan_should_add_mc(dmi, vlan_dev->vlan_dev->old_mc_list)) {
+                                 dev_mc_add(real_dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+                                 printk(KERN_INFO "vlan: add %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address to master interface\n",
+                                        dmi->dmi_addr[0],
+                                        dmi->dmi_addr[1],
+                                        dmi->dmi_addr[2],
+                                        dmi->dmi_addr[3],
+                                        dmi->dmi_addr[4],
+                                        dmi->dmi_addr[5]);
+                         }
+                 }
+    
+                 /* looking for addresses to delete from master's list */
+                 for (dmi = vlan_dev->mc_list; dmi!=NULL; dmi=dmi->next) {
+                         if (vlan_should_add_mc(dmi, vlan_dev->mc_list)) {
+                                 /* if we think we should add it to the new list, then we should really
+                                  * delete it from the real list on the underlying device.
+                                  */
+                                 dev_mc_delete(real_dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+                                 printk(KERN_INFO "vlan: del %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address from master interface\n",
+                                        dmi->dmi_addr[0],
+                                        dmi->dmi_addr[1],
+                                        dmi->dmi_addr[2],
+                                        dmi->dmi_addr[3],
+                                        dmi->dmi_addr[4],
+                                        dmi->dmi_addr[5]);
+                         }
+                 }
+    
+                 /* save multicast list */
+                 vlan_copy_mc_list(vlan_dev->mc_list, vlan_dev->vlan_dev);
+         }/* if we were sent a valid device */
+ }/* vlan_dev_set_multicast */
+ 
+ 
+ /** dmi is a single entry into a dev_mc_list, a single node.  mc_list is
+  *  an entire list, and we'll iterate through it.
+  */
+ int vlan_should_add_mc(struct dev_mc_list *dmi, struct dev_mc_list *mc_list) {
+         struct dev_mc_list *idmi; /* iterator */
+ 
+         for (idmi=mc_list; idmi!=NULL;) {
+                 if (vlan_dmi_equals(dmi, idmi)) {
+                         if (dmi->dmi_users > idmi->dmi_users)
+                                 return 1;
+                         else
+                                 return 0;
+                 }
+                 else {
+                         idmi = idmi->next;
+                 }
+         }
+    
+         return 1;
+ }
+ 
+ 
+ void vlan_copy_mc_list(struct dev_mc_list *mc_list, struct vlan_dev_info *vlan_info) {
+         struct dev_mc_list *dmi, *new_dmi;
+    
+         vlan_destroy_mc_list(vlan_info->old_mc_list);
+         vlan_info->old_mc_list = NULL;
+ 
+         for (dmi=mc_list; dmi!=NULL; dmi=dmi->next) {
+                 new_dmi = kmalloc(sizeof(*new_dmi), GFP_KERNEL);
+                 if (new_dmi == NULL) {
+                         printk(KERN_ERR "vlan: cannot allocate memory. Multicast may not work properly from now.\n");
+                         return;
+                 }
+       
+                 new_dmi->next = vlan_info->old_mc_list;
+                 vlan_info->old_mc_list = new_dmi;
+       
+                 new_dmi->dmi_addrlen = dmi->dmi_addrlen;
+                 memcpy(new_dmi->dmi_addr, dmi->dmi_addr, dmi->dmi_addrlen);
+                 new_dmi->dmi_users = dmi->dmi_users;
+                 new_dmi->dmi_gusers = dmi->dmi_gusers;
+         }
+ }
+ 
+ void vlan_flush_mc_list(struct device *dev) {
+         struct dev_mc_list *dmi = dev->mc_list;
+ 
+         while (dmi) {
+                 dev_mc_delete(dev, dmi->dmi_addr, dmi->dmi_addrlen, 0);
+                 printk(KERN_INFO "vlan: del %.2x:%.2x:%.2x:%.2x:%.2x:%.2x mcast address from master interface\n",
+                        dmi->dmi_addr[0],
+                        dmi->dmi_addr[1],
+                        dmi->dmi_addr[2],
+                        dmi->dmi_addr[3],
+                        dmi->dmi_addr[4],
+                        dmi->dmi_addr[5]);
+                 dmi = dev->mc_list;
+         }
+    
+         vlan_destroy_mc_list(dev->mc_list);
+         if (dev->vlan_dev) {
+                 vlan_destroy_mc_list(dev->vlan_dev->old_mc_list);
+                 dev->vlan_dev->old_mc_list = NULL;
+         }
+         dev->mc_list = NULL;
+ }/* vlan_flush_mc_list */
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/vlanproc.c linux.dev/net/802_1Q/vlanproc.c
*** linux/net/802_1Q/vlanproc.c	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/vlanproc.c	Thu Oct 26 22:09:01 2000
***************
*** 0 ****
--- 1,654 ----
+ /* * -*- linux-c -*- */
+ /*****************************************************************************
+  * vlanproc.c	VLAN Module. /proc filesystem interface.
+ *
+ * Author:	Ben Greear, <greearb@candelatech.com> coppied from wanproc.c
+ *               by: Gene Kozin	<genek@compuserve.com>
+ *
+ * Copyright:	(c) 1998-2000 Ben Greear
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ * ============================================================================
+ * Jan 20, 1998        Ben Greear     Initial Version
+ *****************************************************************************/
+ 
+ #include <linux/config.h>
+ #include <linux/stddef.h>	/* offsetof(), etc. */
+ #include <linux/errno.h>	/* return codes */
+ #include <linux/kernel.h>
+ #include <linux/malloc.h>	/* kmalloc(), kfree() */
+ #include <linux/mm.h>		/* verify_area(), etc. */
+ #include <linux/string.h>	/* inline mem*, str* functions */
+ #include <linux/init.h>		/* __initfunc et al. */
+ #include <asm/segment.h>	/* kernel <-> user copy */
+ #include <asm/byteorder.h>	/* htons(), etc. */
+ #include <asm/uaccess.h>	/* copy_to_user */
+ #include <asm/io.h>
+ #include <linux/proc_fs.h>
+ #include <linux/fs.h>
+ #include <linux/netdevice.h>
+ #include <linux/if_vlan.h>
+ #include "vlanproc.h"
+ #include "vlan.h"
+ 
+ /****** Defines and Macros **************************************************/
+ 
+ #ifndef	min
+ #define min(a,b) (((a)<(b))?(a):(b))
+ #endif
+ #ifndef	max
+ #define max(a,b) (((a)>(b))?(a):(b))
+ #endif
+ 
+ 
+ /****** Function Prototypes *************************************************/
+ 
+ #ifdef CONFIG_PROC_FS
+ 
+ /* Proc filesystem interface */
+ static int vlan_proc_perms(struct inode *, int);
+ static ssize_t vlan_proc_read(struct file* file, char* buf, size_t count,
+                               loff_t *ppos);
+ 
+ /* Methods for preparing data for reading proc entries */
+ 
+ static int vlan_config_get_info(char* buf, char** start, off_t offs, int len,
+                                 int dummy);
+ static int vlandev_get_info(char* buf, char** start, off_t offs, int len,
+                             int dummy);
+ 
+ 
+ /* Miscellaneous */
+ 
+ /*
+  *	Global Data
+  */
+ 
+ /*
+  *	Names of the proc directory entries 
+  */
+ 
+ static char name_root[]	 = "vlan";
+ static char name_conf[]	 = "config";
+ static char term_msg[]   = "***KERNEL:  Out of buffer space!***\n";
+ 
+ 
+ /*
+  *	VLAN device IOCTL.
+  *	o execute requested action or pass command to the device driver
+  */
+ 
+ int vlan_ioctl(struct inode* inode, struct file* file,
+                unsigned int cmd, unsigned long arg) {
+         int err = 0;
+         /*
+           struct proc_dir_entry* dent;
+           struct device* dev;
+         */
+         struct vlan_ioctl_args args;
+    
+         printk(VLAN_DBG __FUNCTION__ ": cmd: %x\n", cmd);
+ 
+    /* everything here needs root permissions, except aguably the
+     * hack ioctls for sending packets.  However, I know _I_ don't
+     * want users running that on my network! --BLG
+     */
+         if (!capable(CAP_NET_ADMIN)){
+                 return -EPERM;
+         }
+ 		
+         if ((cmd >> 8) != VLAN_IOCTL) {
+                 printk(VLAN_DBG __FUNCTION__ ": Not a VLAN IOCTL: %x \n", cmd);
+                 return -EINVAL;
+         }
+    
+         if (copy_from_user(&args, (void*)arg, sizeof(struct vlan_ioctl_args)))
+                 return -EFAULT;
+ 
+    /* Null terminate this sucker, just in case. */
+         args.dev1[23] = 0;
+         args.u.dev2[23] = 0;
+ 
+    /*
+    dent = inode->u.generic_ip;
+    if ((dent == NULL) || (dent->data == NULL))
+      return -EINVAL;
+ 
+    dev = dent->data;
+    */
+    
+         switch (cmd)
+         {
+         case SET_INGRESS_PRIORITY_IOCTL:
+                 err = vlan_dev_set_ingress_priority(args.dev1, args.u.skb_priority, args.vlan_qos);
+                 break;
+ 
+         case SET_EGRESS_PRIORITY_IOCTL:
+                 err = vlan_dev_set_egress_priority(args.dev1, args.u.skb_priority, args.vlan_qos);
+                 break;
+ 
+         case SET_VLAN_FLAG_IOCTL:
+                 err = vlan_dev_set_vlan_flag(args.dev1, args.u.flag, args.vlan_qos);
+                 break;
+ 
+         case SET_NAME_TYPE_IOCTL:
+                 if ((args.u.name_type >= 0) && (args.u.name_type < VLAN_NAME_TYPE_HIGHEST)) {
+                         vlan_name_type = args.u.name_type;
+                         err = 0;
+                 }
+                 else {
+                         err = -EINVAL;
+                 }
+                 break;
+          
+                 /* TODO:  Figure out how to pass info back...
+                    case GET_INGRESS_PRIORITY_IOCTL:
+                    err = vlan_dev_get_ingress_priority(args);
+                    break;
+ 
+                    case GET_EGRESS_PRIORITY_IOCTL:
+                    err = vlan_dev_get_egress_priority(args);
+                    break;
+                 */
+          
+         case ADD_VLAN_IOCTL:
+                 /* we have been given the name of the Ethernet Device we want to
+                  * talk to:  args.dev1   We also have the
+                  * VLAN ID:  args.u.VID
+                  */
+                 if (register_802_1Q_vlan_device(args.dev1, args.u.VID)) {
+                         err = 0;
+                 }
+                 else {
+                         err = -EINVAL;
+                 }
+                 break;
+ 
+         case DEL_VLAN_IOCTL:
+                 /* Here, the args.dev1 is the actual VLAN we want to get rid of. */
+ 
+                 err = unregister_802_1Q_vlan_device(args.dev1);
+                 break;
+ 
+         default:
+                 /* pass on to underlying device instead?? */
+                 printk(VLAN_DBG __FUNCTION__ ": Unknown VLAN IOCTL: %x \n", cmd);
+                 return -EINVAL;
+         }/* switch */
+         return err;
+ }
+ 
+ /*
+  *	Structures for interfacing with the /proc filesystem.
+  *	VLAN creates its own directory /proc/net/vlan with the folowing
+  *	entries:
+  *	config		device status/configuration
+  *	<device>	entry for each  device
+  */
+ 
+ /*
+  *	Generic /proc/net/vlan/<file> file and inode operations 
+  */
+ 
+ static struct file_operations vlan_fops = {
+         NULL,			/* lseek   */
+         vlan_proc_read,	        /* read	   */
+         NULL,        		/* write   */
+         NULL,			/* readdir */
+         NULL,			/* select  */
+         vlan_ioctl,			/* ioctl   */
+         NULL,			/* mmap	   */
+         NULL,			/* no special open code	   */
+         NULL,			/* flush */
+         NULL,			/* no special release code */
+         NULL  			/* can't fsync */
+ };
+ 
+ static struct inode_operations vlan_inode = {
+         &vlan_fops,                  
+         NULL,			/* create */
+         NULL,			/* lookup */
+         NULL,			/* link */
+         NULL,			/* unlink */
+         NULL,			/* symlink */
+         NULL,			/* mkdir */
+         NULL,			/* rmdir */
+         NULL,			/* mknod */
+         NULL,			/* rename */
+         NULL,			/* follow link */
+         NULL,			/* readlink */
+         NULL,			/* readpage */
+         NULL,			/* writepage */
+         NULL,			/* bmap */
+         NULL,			/* truncate */
+         vlan_proc_perms
+ };
+ 
+ /*
+  *	/proc/net/vlan/<device> file and inode operations
+  */
+ 
+ static struct file_operations vlandev_fops = {
+         NULL,			/* lseek   */
+         vlan_proc_read,	        /* read	   */
+         NULL,        		/* write   */
+         NULL,			/* readdir */
+         NULL,			/* select  */
+         vlan_ioctl,	                /* ioctl   */
+         NULL,			/* mmap	   */
+         NULL,			/* no special open code	   */
+         NULL,			/* flush */
+         NULL,			/* no special release code */
+         NULL			        /* can't fsync */
+ };
+ 
+ static struct inode_operations vlandev_inode = {
+         &vlandev_fops,
+         NULL,			/* create */
+         NULL,			/* lookup */
+         NULL,			/* link */
+         NULL,			/* unlink */
+         NULL,			/* symlink */
+         NULL,			/* mkdir */
+         NULL,			/* rmdir */
+         NULL,			/* mknod */
+         NULL,			/* rename */
+         NULL,			/* readlink */
+         NULL,			/* follow_link */
+         NULL,			/* readpage */
+         NULL,			/* writepage */
+         NULL,			/* bmap */
+         NULL,			/* truncate */
+         vlan_proc_perms
+ };
+ 
+ 
+ /*
+  * Proc filesystem derectory entries.
+  */
+ 
+ /*
+  *	/proc/net/vlan 
+  */
+ 
+ static struct proc_dir_entry proc_vlan = {
+         0,			/* .low_ino */
+         sizeof(name_root) - 1,	/* .namelen */
+         name_root,		/* .name */
+         0555 | S_IFDIR,		/* .mode */
+         2,			/* .nlink */
+         0,			/* .uid */
+         0,			/* .gid */
+         0,			/* .size */
+         &proc_dir_inode_operations, /* .ops */
+         NULL,			/* .get_info */
+         NULL,			/* .fill_node */
+         NULL,			/* .next */
+         NULL,			/* .parent */
+         NULL,			/* .subdir */
+         NULL,			/* .data */
+ };
+ 
+ /*
+  *	/proc/net/vlan/config 
+  */
+  
+ static struct proc_dir_entry proc_vlan_conf = {
+         0,    			/* .low_ino */
+         sizeof(name_conf) - 1,	/* .namelen */
+         name_conf,   		/* .name */
+         0444 | S_IFREG,		/* .mode */
+         1,   			/* .nlink */
+         0,	        		/* .uid */
+         0,		        	/* .gid */
+         0,   			/* .size */
+         &vlan_inode,	        	/* .ops */
+         &vlan_config_get_info,	/* .get_info */
+         NULL,			/* .fill_node */
+         NULL,			/* .next */
+         NULL,			/* .parent */
+         NULL,			/* .subdir */
+         NULL,			/* .data */
+ };
+ 
+ 
+ /* Strings */
+ static char conf_hdr[] = "VLAN Dev name  | VLAN ID\n";
+ 
+ 
+ /*
+  *	Interface functions
+  */
+ 
+ /*
+  *	Initialize vlan proc interface.
+  */
+ 
+ __initfunc(int vlan_proc_init (void)) {
+         int err = proc_register(proc_net, &proc_vlan);
+ 
+         if (!err) {
+                 proc_register(&proc_vlan, &proc_vlan_conf);
+         }
+         return err;
+ }
+ 
+ /*
+  *	Clean up router proc interface.
+  */
+ 
+ void vlan_proc_cleanup (void) {
+         proc_unregister(&proc_vlan, proc_vlan_conf.low_ino);
+         proc_unregister(proc_net, proc_vlan.low_ino);
+ }
+ 
+ 
+ /*
+  *	Add directory entry for VLAN device.
+  */
+ 
+ int vlan_proc_add_dev (struct device* vlandev) {
+         if (!vlandev->vlan_dev) {
+                 printk(KERN_ERR "ERROR:  vlan_proc_add, device -:%s:- is NOT a VLAN\n",
+                        vlandev->name);
+                 return -EINVAL;
+         }
+    
+         memset(&(vlandev->vlan_dev->dent), 0, sizeof(vlandev->vlan_dev->dent));
+         vlandev->vlan_dev->dent.namelen = strlen(vlandev->name);
+         vlandev->vlan_dev->dent.name = vlandev->name;
+         vlandev->vlan_dev->dent.mode = 0444 | S_IFREG;
+         vlandev->vlan_dev->dent.nlink = 1;
+         vlandev->vlan_dev->dent.ops = &vlandev_inode;
+         vlandev->vlan_dev->dent.get_info = &vlandev_get_info;
+         vlandev->vlan_dev->dent.data = vlandev;
+ 
+ #ifdef VLAN_DEBUG
+         printk(KERN_ERR "vlan_proc_add, device -:%s:- being added.\n",
+                vlandev->name);
+ #endif
+    
+         return proc_register(&proc_vlan, &vlandev->vlan_dev->dent);
+ }
+ 
+ 
+ 
+ /*
+  *	Delete directory entry for VLAN device.
+  */
+ int vlan_proc_rem_dev(struct device* vlandev) {
+         if (!vlandev || !vlandev->vlan_dev) {
+ #ifdef VLAN_DEBUG
+                 printk(VLAN_DBG __FUNCTION__ ": invalid argument: %p\n", vlandev);
+ #endif
+                 return -EINVAL;
+         }
+    
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": calling proc_unregister for dev: %p\n",
+                vlandev);
+ #endif
+         return proc_unregister(&proc_vlan, vlandev->vlan_dev->dent.low_ino);
+ }
+ 
+ 
+ /****** Proc filesystem entry points ****************************************/
+ 
+ /*
+  *	Verify access rights.
+  */
+ 
+ static int vlan_proc_perms (struct inode* inode, int op) {
+         return 0;
+ }
+ 
+ /*
+  *	Read VLAN proc directory entry.
+  *	This is universal routine for reading all entries in /proc/net/vlan
+  *	directory.  Each directory entry contains a pointer to the 'method' for
+  *	preparing data for that entry.
+  *	o verify arguments
+  *	o allocate kernel buffer
+  *	o call get_info() to prepare data
+  *	o copy data to user space
+  *	o release kernel buffer
+  *
+  *	Return:	number of bytes copied to user space (0, if no data)
+  *		<0	error
+  */
+ static ssize_t vlan_proc_read(struct file* file, char* buf, size_t count,
+                               loff_t *ppos) {
+         struct inode *inode = file->f_dentry->d_inode;
+         struct proc_dir_entry* dent;
+         char* page;
+         int pos, offs, len;
+ 
+         if (count <= 0)
+                 return 0;
+ 		
+         dent = inode->u.generic_ip;
+         if ((dent == NULL) || (dent->get_info == NULL))
+                 return 0;
+ 		
+         page = kmalloc(VLAN_PROC_BUFSZ, GFP_KERNEL);
+         VLAN_MEM_DBG("page malloc, addr: %p  size: %i\n", page, VLAN_PROC_BUFSZ);
+    
+         if (page == NULL)
+                 return -ENOBUFS;
+ 		
+         pos = dent->get_info(page, dent->data, 0, 0, 0);
+         offs = file->f_pos;
+         if (offs < pos) {
+                 len = min(pos - offs, count);
+                 if (copy_to_user(buf, (page + offs), len)) {
+                         return -EFAULT;
+                 }
+                 file->f_pos += len;
+         }
+         else {
+                 len = 0;
+         }
+ 
+         kfree(page);
+         VLAN_FMEM_DBG("page free, addr: %p\n", page);
+         return len;
+ }/* vlan_proc_read */
+ 
+ 
+ static int vlan_proc_get_vlan_info(char* buf, unsigned int cnt) {
+         struct device* vlandev = NULL;
+         struct vlan_group* grp = NULL;
+         int i = 0;
+         char* nm_type = NULL;
+    
+         printk(VLAN_DBG __FUNCTION__ ": cnt == %i\n", cnt);
+ 
+         if (vlan_name_type == VLAN_NAME_TYPE_RAW_PLUS_VID) {
+                 nm_type = "VLAN_NAME_TYPE_RAW_PLUS_VID";
+         }
+         else if (vlan_name_type == VLAN_NAME_TYPE_PLUS_VID_NO_PAD) {
+                 nm_type = "VLAN_NAME_TYPE_PLUS_VID_NO_PAD";
+         }
+         else if (vlan_name_type == VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD) {
+                 nm_type = "VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD";
+         }
+         else if (vlan_name_type == VLAN_NAME_TYPE_PLUS_VID) {
+                 nm_type = "VLAN_NAME_TYPE_PLUS_VID";
+         }
+         else {
+                 nm_type = "UNKNOWN";
+         }
+    
+         cnt += sprintf(buf + cnt, "Name-Type: %s  bad_proto_recvd: %lu\n",
+                        nm_type, vlan_bad_proto_recvd);
+    
+         for (grp = p802_1Q_vlan_list; grp != NULL; grp = grp->next) {
+                 /* loop through all devices for this device */
+                 printk(VLAN_DBG __FUNCTION__ ": found a group, addr: %p\n", grp);
+                 for (i = 0; i < VLAN_GROUP_ARRAY_LEN; i++) {
+                         /* printk(VLAN_DBG __FUNCTION__ ": checking index[%i]\n", i); */
+                         if ((vlandev = grp->vlan_devices[i])) {
+                                 printk(VLAN_DBG __FUNCTION__ ": found a vlan_dev, addr: %p\n", vlandev);
+                                 if ((cnt + 100) > VLAN_PROC_BUFSZ) {
+                                         if ((cnt + strlen(term_msg)) >= VLAN_PROC_BUFSZ) {
+                                                 /* should never get here */
+                                                 return cnt;
+                                         }
+                                         else {
+                                                 cnt += sprintf(buf + cnt, "%s", term_msg);
+                                                 return cnt;
+                                         }
+                                 }/* if running out of buffer space */
+                                 else {
+                                         if (!vlandev->vlan_dev) {
+                                                 printk(KERN_ERR __FUNCTION__ ": ERROR: vlandev->vlan_dev is NULL\n");
+                                         }
+                                         else {
+                                                 printk(VLAN_DBG __FUNCTION__ ": got a good vlandev, addr: %p\n", vlandev->vlan_dev);
+                                                 cnt += sprintf(buf + cnt, "%-15s| %d | %s\n",
+                                                                vlandev->name, vlandev->vlan_dev->vlan_id, vlandev->vlan_dev->real_dev->name);
+                                         }/* else */
+                                 }/* else */
+                         }/* if we have a vlan of this number */
+                 }/* for all VLAN's */
+         }/* for each vlan group, default is only one.*/
+    
+         return cnt;
+ }/* vlan_proc_get_vlan_info */
+ 
+ /*
+  *	Prepare data for reading 'Config' entry.
+  *	Return length of data.
+  */
+ 
+ static int vlan_config_get_info(char* buf, char** start, off_t offs, int len, 
+                                 int dummy) {
+         strcpy(buf, conf_hdr);
+         return vlan_proc_get_vlan_info(buf, (unsigned int)(strlen(conf_hdr)));
+ }
+ 
+ 
+ /*
+  *	Prepare data for reading <device> entry.
+  *	Return length of data.
+  *
+  *	On entry, the 'start' argument will contain a pointer to VLAN device
+  *	data space.
+  */
+ 
+ static int vlandev_get_info(char* buf, char** start, off_t offs, int len, 
+                             int dummy) {
+         struct device* vlandev = (void*)start;
+         struct net_device_stats* stats;
+         int cnt = 0;
+         struct vlan_priority_tci_mapping* mp;
+         int i;
+    
+ #ifdef VLAN_DEBUG
+         printk(VLAN_DBG __FUNCTION__ ": vlandev: %p\n", vlandev);
+ #endif
+    
+         if ((vlandev == NULL) || (!vlandev->vlan_dev)) {
+                 return 0;
+         }
+ 
+         cnt += sprintf(buf + cnt, "%s  VID: %d  REORDER_HDR: %i\n",
+                        vlandev->name, vlandev->vlan_dev->vlan_id, (int)(vlandev->vlan_dev->flags & 1));
+         stats = (struct net_device_stats*)(vlandev->priv);
+    
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "total frames received", stats->rx_packets);
+ 
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "total bytes received", stats->rx_bytes);
+    
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "Broadcast/Multicast Rcvd", stats->multicast);
+    
+         cnt += sprintf(buf + cnt, "\n%30s: %12lu\n",
+                        "total frames transmitted", stats->tx_packets);
+    
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "total bytes transmitted", stats->tx_bytes);
+ 
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "total headroom inc", vlandev->vlan_dev->cnt_inc_headroom_on_tx);
+         
+         cnt += sprintf(buf + cnt, "%30s: %12lu\n",
+                        "total encap on xmit", vlandev->vlan_dev->cnt_encap_on_xmit);
+ 
+         cnt += sprintf(buf + cnt, "Device: %s", vlandev->vlan_dev->real_dev->name);
+ 
+    /* now show all PRIORITY mappings relating to this VLAN */
+         cnt += sprintf(buf + cnt, "\nINGRESS priority mappings: 0:%lu  1:%lu  2:%lu  3:%lu  4:%lu  5:%lu  6:%lu 7:%lu\n",
+                        vlandev->vlan_dev->ingress_priority_map[0],
+                        vlandev->vlan_dev->ingress_priority_map[1],
+                        vlandev->vlan_dev->ingress_priority_map[2],
+                        vlandev->vlan_dev->ingress_priority_map[3],
+                        vlandev->vlan_dev->ingress_priority_map[4],
+                        vlandev->vlan_dev->ingress_priority_map[5],
+                        vlandev->vlan_dev->ingress_priority_map[6],
+                        vlandev->vlan_dev->ingress_priority_map[7]);
+ 
+         cnt += sprintf(buf + cnt, "EGRESSS priority Mappings: ");
+    
+         for (i = 0; i<16; i++) {
+                 mp = vlandev->vlan_dev->egress_priority_map[i];
+                 while (mp) {
+                         cnt += sprintf(buf + cnt, "%lu:%hu ", mp->priority, ((mp->vlan_qos >> 13) & 0x7));
+ 
+                         if ((cnt + 100) > VLAN_PROC_BUFSZ) {
+                                 if ((cnt + strlen(term_msg)) >= VLAN_PROC_BUFSZ) {
+                                         /* should never get here */
+                                         return cnt;
+                                 }
+                                 else {
+                                         cnt += sprintf(buf + cnt, "%s", term_msg);
+                                         return cnt;
+                                 }
+                         }/* if running out of buffer space */
+                         mp = mp->next;
+                 }
+         }/* for */
+ 
+         cnt += sprintf(buf + cnt, "\n");
+ 
+         return cnt;
+ }
+ 
+ 
+ /*
+  *	End
+  */
+  
+ #else
+ 
+ /*
+  *	No /proc - output stubs
+  */
+  
+ __initfunc(int vlan_proc_init(void))
+ {
+         return 0;
+ }
+ 
+ void vlan_proc_cleanup(void)
+ {
+         return;
+ }
+ 
+ 
+ int vlan_proc_add_dev(struct device *vlandev)
+ {
+         return 0;
+ }
+ 
+ int vlan_proc_rem_dev(struct device *vlandev)
+ {
+         return 0;
+ }
+ 
+ #endif
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/802_1Q/vlanproc.h linux.dev/net/802_1Q/vlanproc.h
*** linux/net/802_1Q/vlanproc.h	Wed Dec 31 17:00:00 1969
--- linux.dev/net/802_1Q/vlanproc.h	Thu Oct 26 00:25:17 2000
***************
*** 0 ****
--- 1,27 ----
+ 
+ #ifndef __BEN_VLAN_PROC_INC__
+ #define __BEN_VLAN_PROC_INC__
+ 
+ 
+ int vlan_proc_init(void);
+ 
+ int vlan_proc_rem_dev(struct device* vlandev);
+ int vlan_proc_add_dev (struct device* vlandev);
+ void vlan_proc_cleanup (void);
+ 
+ 
+ #define	VLAN_PROC_BUFSZ	(4096)	/* buffer size for printing proc info */
+ 
+ /****** Data Types **********************************************************/
+ 
+ /*
+ typedef struct vlan_stat_entry {
+    struct vlan_stat_entry *	next;
+    char *description;		* description string *
+    void *data;			* -> data *
+    unsigned data_type;		* data type *
+ } vlan_stat_entry_t;
+ */
+ 
+ 
+ #endif
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/Config.in linux.dev/net/Config.in
*** linux/net/Config.in	Tue Jan  4 11:12:26 2000
--- linux.dev/net/Config.in	Wed Oct 11 20:07:47 2000
***************
*** 44,47 ****
--- 44,50 ----
    fi
    bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
+ 
+   bool '802.1Q VLAN Support (EXPERIMENTAL)' CONFIG_VLAN_802_1Q
+ 
  #  if [ "$CONFIG_LLC" = "y" ]; then
  #   bool 'Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/Makefile linux.dev/net/Makefile
*** linux/net/Makefile	Mon Mar 22 12:18:17 1999
--- linux.dev/net/Makefile	Wed Oct 11 20:07:47 2000
***************
*** 11,15 ****
  ALL_SUB_DIRS := 802 ax25 bridge core ethernet ipv4 ipv6 ipx unix appletalk \
  		netrom rose lapb x25 wanrouter netlink sched packet sunrpc \
! 		econet irda #decnet
  SUB_DIRS     := core ethernet sched
  MOD_LIST_NAME := NET_MISC_MODULES
--- 11,15 ----
  ALL_SUB_DIRS := 802 ax25 bridge core ethernet ipv4 ipv6 ipx unix appletalk \
  		netrom rose lapb x25 wanrouter netlink sched packet sunrpc \
! 		econet irda 802_1Q #decnet
  SUB_DIRS     := core ethernet sched
  MOD_LIST_NAME := NET_MISC_MODULES
***************
*** 60,63 ****
--- 60,67 ----
  ifeq ($(CONFIG_BRIDGE),y)
  SUB_DIRS += bridge
+ endif
+ 
+ ifeq ($(CONFIG_VLAN_802_1Q),y)
+ SUB_DIRS += 802_1Q
  endif
  
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/core/#dev.c# linux.dev/net/core/#dev.c#
*** linux/net/core/#dev.c#	Wed Dec 31 17:00:00 1969
--- linux.dev/net/core/#dev.c#	Sun Oct 15 15:04:26 2000
***************
*** 0 ****
--- 1,2378 ----
+ /*
+  * 	NET3	Protocol independent device support routines.
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  *
+  *	Derived from the non IP parts of dev.c 1.0.19
+  * 		Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+  *				Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *				Mark Evans, <evansmp@uhura.aston.ac.uk>
+  *
+  *	Additional Authors:
+  *		Florian la Roche <rzsfl@rz.uni-sb.de>
+  *		Alan Cox <gw4pts@gw4pts.ampr.org>
+  *		David Hinds <dhinds@allegro.stanford.edu>
+  *		Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
+  *		Adam Sulmicki <adam@cfar.umd.edu>
+  *
+  *	Changes:
+  *		Marcelo Tosatti <marcelo@conectiva.com.br> : dont accept mtu 0 or <
+  *		Alan Cox	:	device private ioctl copies fields back.
+  *		Alan Cox	:	Transmit queue code does relevant stunts to
+  *					keep the queue safe.
+  *		Alan Cox	:	Fixed double lock.
+  *		Alan Cox	:	Fixed promisc NULL pointer trap
+  *		????????	:	Support the full private ioctl range
+  *		Alan Cox	:	Moved ioctl permission check into drivers
+  *		Tim Kordas	:	SIOCADDMULTI/SIOCDELMULTI
+  *		Alan Cox	:	100 backlog just doesn't cut it when
+  *					you start doing multicast video 8)
+  *		Alan Cox	:	Rewrote net_bh and list manager.
+  *		Alan Cox	: 	Fix ETH_P_ALL echoback lengths.
+  *		Alan Cox	:	Took out transmit every packet pass
+  *					Saved a few bytes in the ioctl handler
+  *		Alan Cox	:	Network driver sets packet type before calling netif_rx. Saves
+  *					a function call a packet.
+  *		Alan Cox	:	Hashed net_bh()
+  *		Richard Kooijman:	Timestamp fixes.
+  *		Alan Cox	:	Wrong field in SIOCGIFDSTADDR
+  *		Alan Cox	:	Device lock protection.
+  *		Alan Cox	: 	Fixed nasty side effect of device close changes.
+  *		Rudi Cilibrasi	:	Pass the right thing to set_mac_address()
+  *		Dave Miller	:	32bit quantity for the device lock to make it work out
+  *					on a Sparc.
+  *		Bjorn Ekwall	:	Added KERNELD hack.
+  *		Alan Cox	:	Cleaned up the backlog initialise.
+  *		Craig Metz	:	SIOCGIFCONF fix if space for under
+  *					1 device.
+  *	    Thomas Bogendoerfer :	Return ENODEV for dev_open, if there
+  *					is no device open function.
+  *		Andi Kleen	:	Fix error reporting for SIOCGIFCONF
+  *	    Michael Chastain	:	Fix signed/unsigned for SIOCGIFCONF
+  *		Cyrus Durgin	:	Cleaned for KMOD
+  *		Adam Sulmicki   :	Bug Fix : Network Device Unload
+  *					A network device unload needs to purge
+  *					the backlog queue.
+  *	Paul Rusty Russel	:	SIOCSIFNAME
+  *	Andrea Arcangeli	:	dev_clear_backlog() needs the
+  *					skb_queue_lock held.
+  */
+ 
+ #include <asm/uaccess.h>
+ #include <asm/system.h>
+ #include <asm/bitops.h>
+ #include <linux/config.h>
+ #include <linux/types.h>
+ #include <linux/kernel.h>
+ #include <linux/sched.h>
+ #include <linux/string.h>
+ #include <linux/mm.h>
+ #include <linux/socket.h>
+ #include <linux/sockios.h>
+ #include <linux/errno.h>
+ #include <linux/interrupt.h>
+ #include <linux/if_ether.h>
+ #include <linux/netdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/notifier.h>
+ #include <linux/skbuff.h>
+ #include <net/sock.h>
+ #include <linux/rtnetlink.h>
+ #include <linux/proc_fs.h>
+ #include <linux/stat.h>
+ #include <net/br.h>
+ #include <net/dst.h>
+ #include <net/pkt_sched.h>
+ #include <net/profile.h>
+ #include <linux/init.h>
+ #include <linux/kmod.h>
+ #ifdef CONFIG_NET_RADIO
+ #include <linux/wireless.h>
+ #endif	/* CONFIG_NET_RADIO */
+ 
+ #ifdef CONFIG_VLAN_802_1Q
+ #include "../802_1Q/vlan.h"
+ #endif
+ 
+ #ifdef CONFIG_PLIP
+ extern int plip_init(void);
+ #endif
+ extern void n2_init(void);
+ extern void c101_init(void);
+ extern int wanxl_init(void);
+ extern int cpc_init(void);
+ extern void sync_ppp_init(void);
+ 
+ NET_PROFILE_DEFINE(dev_queue_xmit)
+ NET_PROFILE_DEFINE(net_bh)
+ NET_PROFILE_DEFINE(net_bh_skb)
+ 
+ 
+ const char *if_port_text[] = {
+   "unknown",
+   "BNC",
+   "10baseT",
+   "AUI",
+   "100baseT",
+   "100baseTX",
+   "100baseFX"
+ };
+ 
+ /*
+  *	The list of packet types we will receive (as opposed to discard)
+  *	and the routines to invoke.
+  *
+  *	Why 16. Because with 16 the only overlap we get on a hash of the
+  *	low nibble of the protocol value is RARP/SNAP/X.25.
+  *
+  *      NOTE:  That is no longer true with the addition of VLAN tags.  Not
+  *             sure which should go first, but I bet it won't make much
+  *             difference if we are running VLANs.  The good news is that
+  *             this protocol won't be in the list unless compiled in, so
+  *             the average user (w/out VLANs) will not be adversly affected.
+  *             --BLG
+  *
+  *		0800	IP
+  *		8100    802.1Q VLAN
+  *		0001	802.3
+  *		0002	AX.25
+  *		0004	802.2
+  *		8035	RARP
+  *		0005	SNAP
+  *		0805	X.25
+  *		0806	ARP
+  *		8137	IPX
+  *		0009	Localtalk
+  *		86DD	IPv6
+  */
+ 
+ struct packet_type *ptype_base[16];		/* 16 way hashed list */
+ struct packet_type *ptype_all = NULL;		/* Taps */
+ 
+ /*
+  *	Device list lock. Setting it provides that interface
+  *	will not disappear unexpectedly while kernel sleeps.
+  */
+  
+ atomic_t dev_lockct = ATOMIC_INIT(0);
+ 
+ /*
+  *	Our notifier list
+  */
+  
+ static struct notifier_block *netdev_chain=NULL;
+ 
+ /*
+  *	Device drivers call our routines to queue packets here. We empty the
+  *	queue in the bottom half handler.
+  */
+ 
+ static struct sk_buff_head backlog;
+ 
+ #ifdef CONFIG_NET_FASTROUTE
+ int netdev_fastroute;
+ int netdev_fastroute_obstacles;
+ struct net_fastroute_stats dev_fastroute_stat;
+ #endif
+ 
+ static void dev_clear_backlog(struct device *dev);
+ 
+ 
+ #define BENS_FAST_DEV_LOOKUP
+ #ifdef BENS_FAST_DEV_LOOKUP
+ /* Fash Device Lookup code.  Should give much better than
+  * linear speed when looking for devices by idx or name.
+  * --Ben (greearb@candelatech.com)
+  */
+ #define FDL_HASH_LEN 256
+ 
+ /* #define FDL_DEBUG */
+ 
+ struct dev_hash_node {
+    struct device* dev;
+    struct dev_hash_node* next;
+ };
+ 
+ struct dev_hash_node* fdl_name_base[FDL_HASH_LEN];/* hashed by name */
+ struct dev_hash_node* fdl_idx_base[FDL_HASH_LEN]; /* hashed by index */
+ int fdl_initialized_yet = 0;
+ 
+ /* TODO:  Make these inline methods */
+ /* Nice cheesy little hash method to be used on device-names (eth0, ppp0, etc) */
+ int fdl_calc_name_idx(const char* dev_name) {
+         int tmp = 0;
+         int i;
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "fdl_calc_name_idx, name: %s\n", dev_name);
+ #endif
+         for (i = 0; dev_name[i]; i++) {
+                 tmp += (int)(dev_name[i]);
+         }
+         if (i > 3) {
+                 tmp += (dev_name[i-2] * 10); /* might add a little spread to the hash */
+                 tmp += (dev_name[i-3] * 100); /* might add a little spread to the hash */
+         }
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "fdl_calc_name_idx, rslt: %i\n", (int)(tmp % FDL_HASH_LEN));
+ #endif
+         return (tmp % FDL_HASH_LEN);
+ }
+ 
+ int fdl_calc_index_idx(const int ifindex) {
+         return (ifindex % FDL_HASH_LEN);
+ }
+ 
+ 
+ /* Better have a lock on the dev_base before calling this... */
+ int __fdl_ensure_init(void) {
+ #ifdef FDL_DEBUG
+    printk(KERN_ERR "__fdl_ensure_init, enter\n");
+ #endif
+    if (! fdl_initialized_yet) {
+       /* only do this once.. */
+       int i;
+       int idx = 0; /* into the hash table */
+       struct device* dev = dev_base;
+       struct dev_hash_node* dhn;
+ 
+ #ifdef FDL_DEBUG
+       printk(KERN_ERR "__fdl_ensure_init, doing real work...");
+ #endif
+ 
+       fdl_initialized_yet = 1; /* it has been attempted at least... */
+ 
+       for (i = 0; i<FDL_HASH_LEN; i++) {
+          fdl_name_base[i] = NULL;
+          fdl_idx_base[i] = NULL;
+       }
+ 
+       /* add any current devices to the hash tables at this time.  Note that
+        * this method must be called with locks on the dev_base acquired.
+        */
+       while (dev) {
+ 
+ #ifdef FDL_DEBUG
+          printk(KERN_ERR "__fdl_ensure_init, dev: %p dev: %s, idx: %i\n", dev, dev->name, idx);
+ #endif
+          /* first, take care of the hash-by-name */
+          idx = fdl_calc_name_idx(dev->name);
+          dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+          if (dhn) {
+             dhn->dev = dev;
+             dhn->next = fdl_name_base[idx];
+             fdl_name_base[idx] = dhn;
+          }
+          else {
+             /* Nasty..couldn't get memory... */
+             return -ENOMEM;
+          }
+ 
+          /* now, do the hash-by-idx */
+          idx = fdl_calc_index_idx(dev->ifindex);
+          dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+          if (dhn) {
+             dhn->dev = dev;
+             dhn->next = fdl_idx_base[idx];
+             fdl_idx_base[idx] = dhn;
+          }
+          else {
+             /* Nasty..couldn't get memory... */
+             return -ENOMEM;
+          }
+          
+          dev = dev->next;
+       }
+       fdl_initialized_yet = 2; /* initialization actually worked */
+    }
+ #ifdef FDL_DEBUG
+    printk(KERN_ERR "__fdl_ensure_init, end, fdl_initialized_yet: %i\n", fdl_initialized_yet);
+ #endif
+    if (fdl_initialized_yet == 2) {
+       return 0;
+    }
+    else {
+       return -1;
+    }
+ }/* fdl_ensure_init */
+ 
+ 
+ /* called from register_netdevice, assumes dev is locked, and that no one
+  * will be calling __find_dev_by_name before this exits.. etc.
+  */
+ int __fdl_register_netdevice(struct device* dev) {
+    if (__fdl_ensure_init() == 0) {
+       /* first, take care of the hash-by-name */
+       int idx = fdl_calc_name_idx(dev->name);
+       struct dev_hash_node* dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+ 
+ #ifdef FDL_DEBUG
+       printk(KERN_ERR "__fdl_register_netdevice, dev: %p dev: %s, idx: %i", dev, dev->name, idx);
+ #endif
+ 
+       if (dhn) {
+          dhn->dev = dev;
+          dhn->next = fdl_name_base[idx];
+          fdl_name_base[idx] = dhn;
+       }
+       else {
+          /* Nasty..couldn't get memory... */
+          /* Don't try to use these hash tables any more... */
+          fdl_initialized_yet = 1; /* tried, but failed */
+          return -ENOMEM;
+       }
+       
+       /* now, do the hash-by-idx */
+       idx = fdl_calc_index_idx(dev->ifindex);
+       dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+ 
+ #ifdef FDL_DEBUG
+       printk(KERN_ERR "__fdl_register_netdevice, ifindex: %i, idx: %i", dev->ifindex, idx);
+ #endif
+ 
+       if (dhn) {
+          dhn->dev = dev;
+          dhn->next = fdl_idx_base[idx];
+          fdl_idx_base[idx] = dhn;
+       }
+       else {
+          /* Nasty..couldn't get memory... */
+          /* Don't try to use these hash tables any more... */
+          fdl_initialized_yet = 1; /* tried, but failed */
+          return -ENOMEM;
+       }
+    }
+    return 0;
+ } /* fdl_register_netdevice */
+ 
+ 
+ /* called from register_netdevice, assumes dev is locked, and that no one
+  * will be calling __find_dev_by_name, etc.  Returns 0 if found & removed one,
+  * returns -1 otherwise.
+  */
+ int __fdl_unregister_netdevice(struct device* dev) {
+    int retval = -1;
+    if (fdl_initialized_yet == 2) { /* If we've been initialized correctly... */
+       /* first, take care of the hash-by-name */
+       int idx = fdl_calc_name_idx(dev->name);
+       struct dev_hash_node* prev = fdl_name_base[idx];
+       struct dev_hash_node* cur = NULL;
+ 
+ #ifdef FDL_DEBUG
+       printk(KERN_ERR "__fdl_unregister_netdevice, dev: %p dev: %s, idx: %i", dev, dev->name, idx);
+ #endif
+ 
+       if (prev) {
+          if (strcmp(dev->name, prev->dev->name) == 0) {
+             /* it's the first one... */
+             fdl_name_base[idx] = prev->next;
+             kfree(prev);
+             retval = 0;
+          }
+          else {
+             cur = prev->next;
+             while (cur) {
+                if (strcmp(dev->name, cur->dev->name) == 0) {
+                   prev->next = cur->next;
+                   kfree(cur);
+                   retval = 0;
+                   break;
+                }
+                else {
+                   prev = cur;
+                   cur = cur->next;
+                }
+             }
+          }
+       }
+ 
+       /* Now, the hash-by-index */
+       idx = fdl_calc_index_idx(dev->ifindex);
+       prev = fdl_idx_base[idx];
+       cur = NULL;
+       if (prev) {
+          if (dev->ifindex == prev->dev->ifindex) {
+             /* it's the first one... */
+             fdl_idx_base[idx] = prev->next;
+             kfree(prev);
+             retval = 0;
+          }
+          else {
+             cur = prev->next;
+             while (cur) {
+                if (dev->ifindex == cur->dev->ifindex) {
+                   prev->next = cur->next;
+                   kfree(cur);
+                   retval = 0;
+                   break;
+                }
+                else {
+                   prev = cur;
+                   cur = cur->next;
+                }
+             }
+          }
+       }
+    }/* if we ensured init OK */
+    return retval;
+ } /* fdl_unregister_netdevice */
+ 
+ 
+ 
+ #endif   /* BENS_FAST_DEV_LOOKUP */
+ 
+ 
+ 
+ /******************************************************************************************
+ 
+ 		Protocol management and registration routines
+ 
+ *******************************************************************************************/
+ 
+ /*
+  *	For efficiency
+  */
+ 
+ int netdev_nit=0;
+ 
+ /*
+  *	Add a protocol ID to the list. Now that the input handler is
+  *	smarter we can dispense with all the messy stuff that used to be
+  *	here.
+  *
+  *	BEWARE!!! Protocol handlers, mangling input packets,
+  *	MUST BE last in hash buckets and checking protocol handlers
+  *	MUST start from promiscous ptype_all chain in net_bh.
+  *	It is true now, do not change it.
+  *	Explantion follows: if protocol handler, mangling packet, will
+  *	be the first on list, it is not able to sense, that packet
+  *	is cloned and should be copied-on-write, so that it will
+  *	change it and subsequent readers will get broken packet.
+  *							--ANK (980803)
+  */
+  
+ void dev_add_pack(struct packet_type *pt)
+ {
+ 	int hash;
+ #ifdef CONFIG_NET_FASTROUTE
+ 	/* Hack to detect packet socket */
+ 	if (pt->data) {
+ 		netdev_fastroute_obstacles++;
+ 		dev_clear_fastroute(pt->dev);
+ 	}
+ #endif
+ 	if(pt->type==htons(ETH_P_ALL))
+ 	{
+ 		netdev_nit++;
+ 		pt->next=ptype_all;
+ 		ptype_all=pt;
+ 	}
+ 	else
+ 	{	
+ 		hash=ntohs(pt->type)&15;
+ 		pt->next = ptype_base[hash];
+ 		ptype_base[hash] = pt;
+ 	}
+ }
+ 
+ 
+ /*
+  *	Remove a protocol ID from the list.
+  */
+  
+ void dev_remove_pack(struct packet_type *pt)
+ {
+ 	struct packet_type **pt1;
+ 	if(pt->type==htons(ETH_P_ALL))
+ 	{
+ 		netdev_nit--;
+ 		pt1=&ptype_all;
+ 	}
+ 	else
+ 		pt1=&ptype_base[ntohs(pt->type)&15];
+ 	for(; (*pt1)!=NULL; pt1=&((*pt1)->next))
+ 	{
+ 		if(pt==(*pt1))
+ 		{
+ 			*pt1=pt->next;
+ 			synchronize_bh();
+ #ifdef CONFIG_NET_FASTROUTE
+ 			if (pt->data)
+ 				netdev_fastroute_obstacles--;
+ #endif
+ 			return;
+ 		}
+ 	}
+ 	printk(KERN_WARNING "dev_remove_pack: %p not found.\n", pt);
+ }
+ 
+ /*****************************************************************************************
+ 
+ 			    Device Interface Subroutines
+ 
+ ******************************************************************************************/
+ 
+ /* 
+  *	Find an interface by name.
+  */
+  
+ struct device *dev_get(const char *name)
+ {
+ 	struct device *dev;
+ 
+ #ifdef BENS_FAST_DEV_LOOKUP
+         int idx = fdl_calc_name_idx(name);
+         struct dev_hash_node* dhn;
+         if (fdl_initialized_yet == 2) {
+ #ifdef FDL_DEBUG
+            printk(KERN_ERR "__dev_get_by_name, name: %s  idx: %i\n", name, idx);
+ #endif
+            dhn = fdl_name_base[idx];
+            while (dhn) {
+               if (strcmp(dhn->dev->name, name) == 0) {
+                  /* printk(KERN_ERR "__dev_get_by_name, found it: %p\n", dhn->dev); */
+                  return dhn->dev;
+               }
+               dhn = dhn->next;
+            }
+            /* printk(KERN_ERR "__dev_get_by_name, didn't find it for name: %s\n", name); */
+            return NULL;
+         }
+ #endif
+ 	for (dev = dev_base; dev != NULL; dev = dev->next) 
+ 	{
+ 		if (strcmp(dev->name, name) == 0)
+ 			return(dev);
+ 	}
+ 	return NULL;
+ }
+ 
+ struct device * dev_get_by_index(int ifindex)
+ {
+ 	struct device *dev;
+ #ifdef BENS_FAST_DEV_LOOKUP
+         int idx = fdl_calc_index_idx(ifindex);
+         struct dev_hash_node* dhn;
+         if (fdl_initialized_yet == 2) { /* have we gone through initialization before... */
+            dhn = fdl_idx_base[idx];
+            while (dhn) {
+               if (dhn->dev->ifindex == ifindex)
+                  return dhn->dev;
+               dhn = dhn->next;
+            }
+            return NULL;
+         }
+ #endif
+ 	for (dev = dev_base; dev != NULL; dev = dev->next) 
+ 	{
+ 		if (dev->ifindex == ifindex)
+ 			return(dev);
+ 	}
+ 	return NULL;
+ }
+ 
+ struct device *dev_getbyhwaddr(unsigned short type, char *ha)
+ {
+ 	struct device *dev;
+ 
+ 	for (dev = dev_base; dev != NULL; dev = dev->next) 
+ 	{
+ 		if (dev->type == type &&
+ 		    memcmp(dev->dev_addr, ha, dev->addr_len) == 0)
+ 			return(dev);
+ 	}
+ 	return(NULL);
+ }
+ 
+ /*
+  *	Passed a format string - eg "lt%d" it will try and find a suitable
+  *	id. Not efficient for many devices, not called a lot..
+  */
+ 
+ int dev_alloc_name(struct device *dev, const char *name)
+ {
+ 	int i;
+ 	/*
+ 	 *	If you need over 100 please also fix the algorithm...
+          *
+          *  Increased it to deal with VLAN interfaces.  It is unlikely
+          *  that this many will ever be added, but it can't hurt! -BLG
+          */
+ 	for(i=0;i<8192;i++)
+ 	{
+ 		sprintf(dev->name,name,i);
+ 		if(dev_get(dev->name)==NULL)
+ 			return i;
+ 	}
+ 	return -ENFILE;	/* Over 8192 of the things .. bail out! */
+ }
+  
+ struct device *dev_alloc(const char *name, int *err)
+ {
+ 	struct device *dev=kmalloc(sizeof(struct device)+16, GFP_KERNEL);
+ 	if(dev==NULL)
+ 	{
+ 		*err=-ENOBUFS;
+ 		return NULL;
+ 	}
+ 	dev->name=(char *)(dev+1);	/* Name string space */
+ 	*err=dev_alloc_name(dev,name);
+ 	if(*err<0)
+ 	{
+ 		kfree(dev);
+ 		return NULL;
+ 	}
+ 	return dev;
+ }
+ 
+ void netdev_state_change(struct device *dev)
+ {
+ 	if (dev->flags&IFF_UP)
+ 		notifier_call_chain(&netdev_chain, NETDEV_CHANGE, dev);
+ }
+ 
+ 
+ /*
+  *	Find and possibly load an interface.
+  */
+  
+ #ifdef CONFIG_KMOD
+ 
+ void dev_load(const char *name)
+ {
+ 	if(!dev_get(name) && capable(CAP_SYS_MODULE))
+ 		request_module(name);
+ }
+ 
+ #else
+ 
+ extern inline void dev_load(const char *unused){;}
+ 
+ #endif
+ 
+ static int default_rebuild_header(struct sk_buff *skb)
+ {
+ 	printk(KERN_DEBUG "%s: default_rebuild_header called -- BUG!\n", skb->dev ? skb->dev->name : "NULL!!!");
+ 	kfree_skb(skb);
+ 	return 1;
+ }
+ 
+ /*
+  *	Prepare an interface for use. 
+  */
+  
+ int dev_open(struct device *dev)
+ {
+ 	int ret = 0;
+ 
+ 	/*
+ 	 *	Is it already up?
+ 	 */
+ 
+ 	if (dev->flags&IFF_UP)
+ 		return 0;
+ 
+ 	/*
+ 	 *	Call device private open method
+ 	 */
+ 	 
+ 	if (dev->open) 
+   		ret = dev->open(dev);
+ 
+ 	/*
+ 	 *	If it went open OK then:
+ 	 */
+ 	 
+ 	if (ret == 0) 
+ 	{
+ 		/*
+ 		 *	nil rebuild_header routine,
+ 		 *	that should be never called and used as just bug trap.
+ 		 */
+ 
+ 		if (dev->rebuild_header == NULL)
+ 			dev->rebuild_header = default_rebuild_header;
+ 
+ 		/*
+ 		 *	Set the flags.
+ 		 */
+ 		dev->flags |= (IFF_UP | IFF_RUNNING);
+ 
+ 		/*
+ 		 *	Initialize multicasting status 
+ 		 */
+ 		dev_mc_upload(dev);
+ 
+ 		/*
+ 		 *	Wakeup transmit queue engine
+ 		 */
+ 		dev_activate(dev);
+ 
+ 		/*
+ 		 *	... and announce new interface.
+ 		 */
+ 		notifier_call_chain(&netdev_chain, NETDEV_UP, dev);
+ 
+ 	}
+ 	return(ret);
+ }
+ 
+ #ifdef CONFIG_NET_FASTROUTE
+ 
+ static __inline__ void dev_do_clear_fastroute(struct device *dev)
+ {
+ 	if (dev->accept_fastpath) {
+ 		int i;
+ 
+ 		for (i=0; i<=NETDEV_FASTROUTE_HMASK; i++)
+ 			dst_release_irqwait(xchg(dev->fastpath+i, NULL));
+ 	}
+ }
+ 
+ void dev_clear_fastroute(struct device *dev)
+ {
+ 	if (dev) {
+ 		dev_do_clear_fastroute(dev);
+ 	} else {
+ 		for (dev = dev_base; dev; dev = dev->next)
+ 			dev_do_clear_fastroute(dev);
+ 	}
+ }
+ #endif
+ 
+ /*
+  *	Completely shutdown an interface.
+  */
+  
+ int dev_close(struct device *dev)
+ {
+ 	if (!(dev->flags&IFF_UP))
+ 		return 0;
+ 
+ 	/* If the device is a slave we should not touch it*/
+ 	if(dev->flags&IFF_SLAVE)
+ 		return -EBUSY;
+                                 
+ 	dev_deactivate(dev);
+ 
+ 	dev_lock_wait();
+ 
+ 	/*
+ 	 *	Call the device specific close. This cannot fail.
+ 	 *	Only if device is UP
+ 	 */
+ 	 
+ 	if (dev->stop)
+ 		dev->stop(dev);
+ 
+ 	if (dev->start)
+ 		printk("dev_close: bug %s still running\n", dev->name);
+ 
+ 	/*
+ 	 *	Device is now down.
+ 	 */
+ 	dev_clear_backlog(dev);
+ 
+ 	dev->flags&=~(IFF_UP|IFF_RUNNING);
+ #ifdef CONFIG_NET_FASTROUTE
+ 	dev_clear_fastroute(dev);
+ #endif
+ 
+ 	/*
+ 	 *	Tell people we are going down
+ 	 */
+ 	notifier_call_chain(&netdev_chain, NETDEV_DOWN, dev);
+ 
+ 	return(0);
+ }
+ 
+ 
+ /*
+  *	Device change register/unregister. These are not inline or static
+  *	as we export them to the world.
+  */
+ 
+ int register_netdevice_notifier(struct notifier_block *nb)
+ {
+ 	return notifier_chain_register(&netdev_chain, nb);
+ }
+ 
+ int unregister_netdevice_notifier(struct notifier_block *nb)
+ {
+ 	return notifier_chain_unregister(&netdev_chain,nb);
+ }
+ 
+ /*
+  *	Support routine. Sends outgoing frames to any network
+  *	taps currently in use.
+  */
+ 
+ void dev_queue_xmit_nit(struct sk_buff *skb, struct device *dev)
+ {
+ 	struct packet_type *ptype;
+ 	get_fast_time(&skb->stamp);
+ 
+ 	for (ptype = ptype_all; ptype!=NULL; ptype = ptype->next) 
+ 	{
+ 		/* Never send packets back to the socket
+ 		 * they originated from - MvS (miquels@drinkel.ow.org)
+ 		 */
+ 		if ((ptype->dev == dev || !ptype->dev) &&
+ 			((struct sock *)ptype->data != skb->sk))
+ 		{
+ 			struct sk_buff *skb2;
+ 			if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
+ 				break;
+ 
+ 			/* Code, following below is wrong.
+ 
+ 			   The only reason, why it does work is that
+ 			   ONLY packet sockets receive outgoing
+ 			   packets. If such a packet will be (occasionally)
+ 			   received by normal packet handler, which expects
+ 			   that mac header is pulled...
+ 			 */
+ 
+ 			/* More sensible variant. skb->nh should be correctly
+ 			   set by sender, so that the second statement is
+ 			   just protection against buggy protocols.
+ 			 */
+ 			skb2->mac.raw = skb2->data;
+ 
+ 			if (skb2->nh.raw < skb2->data || skb2->nh.raw >= skb2->tail) {
+ 				if (net_ratelimit())
+ 					printk(KERN_DEBUG "protocol %04x is buggy, dev %s\n", skb2->protocol, dev->name);
+ 				skb2->nh.raw = skb2->data;
+ 				if (dev->hard_header)
+ 					skb2->nh.raw += dev->hard_header_len;
+ 			}
+ 
+ 			skb2->h.raw = skb2->nh.raw;
+ 			skb2->pkt_type = PACKET_OUTGOING;
+ 			ptype->func(skb2, skb->dev, ptype);
+ 		}
+ 	}
+ }
+ 
+ /*
+  *	Fast path for loopback frames.
+  */
+  
+ void dev_loopback_xmit(struct sk_buff *skb)
+ {
+ 	struct sk_buff *newskb=skb_clone(skb, GFP_ATOMIC);
+ 	if (newskb==NULL)
+ 		return;
+ 
+ 	newskb->mac.raw = newskb->data;
+ 	skb_pull(newskb, newskb->nh.raw - newskb->data);
+ 	newskb->pkt_type = PACKET_LOOPBACK;
+ 	newskb->ip_summed = CHECKSUM_UNNECESSARY;
+ 	if (newskb->dst==NULL)
+ 		printk(KERN_DEBUG "BUG: packet without dst looped back 1\n");
+ 	netif_rx(newskb);
+ }
+ 
+ int dev_queue_xmit(struct sk_buff *skb)
+ {
+ 	struct device *dev = skb->dev;
+ 	struct Qdisc  *q;
+ 
+ #ifdef CONFIG_NET_PROFILE
+ 	start_bh_atomic();
+ 	NET_PROFILE_ENTER(dev_queue_xmit);
+ #endif
+ 
+ 	start_bh_atomic();
+ 	q = dev->qdisc;
+ 	if (q->enqueue) {
+ 		q->enqueue(skb, q);
+ 		qdisc_wakeup(dev);
+ 		end_bh_atomic();
+ 
+ #ifdef CONFIG_NET_PROFILE
+ 	        NET_PROFILE_LEAVE(dev_queue_xmit);
+ 		end_bh_atomic();
+ #endif
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* The device has no queue. Common case for software devices:
+ 	   loopback, all the sorts of tunnels...
+ 
+ 	   Really, it is unlikely that bh protection is necessary here:
+ 	   virtual devices do not generate EOI events.
+ 	   However, it is possible, that they rely on bh protection
+ 	   made by us here.
+ 	 */
+ 	if (dev->flags&IFF_UP) {
+ 		if (netdev_nit) 
+ 			dev_queue_xmit_nit(skb,dev);
+ 		if (dev->hard_start_xmit(skb, dev) == 0) {
+ 			end_bh_atomic();
+ 
+ #ifdef CONFIG_NET_PROFILE
+ 			NET_PROFILE_LEAVE(dev_queue_xmit);
+ 			end_bh_atomic();
+ #endif
+ 
+ 			return 0;
+ 		}
+ 		if (net_ratelimit())
+ 			printk(KERN_DEBUG "Virtual device %s asks to queue packet!\n", dev->name);
+ 	}
+ 	end_bh_atomic();
+ 
+ 	kfree_skb(skb);
+ 
+ #ifdef CONFIG_NET_PROFILE
+ 	NET_PROFILE_LEAVE(dev_queue_xmit);
+ 	end_bh_atomic();
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ 
+ /*=======================================================================
+ 			Receiver rotutines
+   =======================================================================*/
+ 
+ int netdev_dropping = 0;
+ int netdev_max_backlog = 300;
+ atomic_t netdev_rx_dropped;
+ #ifdef CONFIG_CPU_IS_SLOW
+ int net_cpu_congestion;
+ #endif
+ 
+ #ifdef CONFIG_NET_HW_FLOWCONTROL
+ int netdev_throttle_events;
+ static unsigned long netdev_fc_mask = 1;
+ unsigned long netdev_fc_xoff = 0;
+ 
+ static struct
+ {
+ 	void (*stimul)(struct device *);
+ 	struct device *dev;
+ } netdev_fc_slots[32];
+ 
+ int netdev_register_fc(struct device *dev, void (*stimul)(struct device *dev))
+ {
+ 	int bit = 0;
+ 	unsigned long flags;
+ 
+ 	save_flags(flags);
+ 	cli();
+ 	if (netdev_fc_mask != ~0UL) {
+ 		bit = ffz(netdev_fc_mask);
+ 		netdev_fc_slots[bit].stimul = stimul;
+ 		netdev_fc_slots[bit].dev = dev;
+ 		set_bit(bit, &netdev_fc_mask);
+ 		clear_bit(bit, &netdev_fc_xoff);
+ 	}
+ 	restore_flags(flags);
+ 	return bit;
+ }
+ 
+ void netdev_unregister_fc(int bit)
+ {
+ 	unsigned long flags;
+ 
+ 	save_flags(flags);
+ 	cli();
+ 	if (bit > 0) {
+ 		netdev_fc_slots[bit].stimul = NULL;
+ 		netdev_fc_slots[bit].dev = NULL;
+ 		clear_bit(bit, &netdev_fc_mask);
+ 		clear_bit(bit, &netdev_fc_xoff);
+ 	}
+ 	restore_flags(flags);
+ }
+ 
+ static void netdev_wakeup(void)
+ {
+ 	unsigned long xoff;
+ 
+ 	cli();
+ 	xoff = netdev_fc_xoff;
+ 	netdev_fc_xoff = 0;
+ 	netdev_dropping = 0;
+ 	netdev_throttle_events++;
+ 	while (xoff) {
+ 		int i = ffz(~xoff);
+ 		xoff &= ~(1<<i);
+ 		netdev_fc_slots[i].stimul(netdev_fc_slots[i].dev);
+ 	}
+ 	sti();
+ }
+ #endif
+ 
+ static void dev_clear_backlog(struct device *dev)
+ {
+ 	struct sk_buff *curr;
+ 	unsigned long flags;
+ 
+ 	/*
+ 	 *
+ 	 *  Let now clear backlog queue. -AS
+ 	 *
+ 	 *  We are competing here both with netif_rx() and net_bh().
+ 	 *  We don't want either of those to mess with skb ptrs
+ 	 *  while we work on them, thus we must grab the
+ 	 *  skb_queue_lock.
+ 	 */ 
+ 
+ 	if (backlog.qlen) {
+ 	repeat:
+ 		spin_lock_irqsave(&skb_queue_lock, flags);
+ 		for (curr = backlog.next;
+ 		     curr != (struct sk_buff *)(&backlog);
+ 		     curr = curr->next)
+ 			if (curr->dev == dev)
+ 			{
+ 				__skb_unlink(curr, &backlog);
+ 				spin_unlock_irqrestore(&skb_queue_lock, flags);
+ 				kfree_skb(curr);
+ 				goto repeat;
+ 			}
+ 		spin_unlock_irqrestore(&skb_queue_lock, flags);
+ #ifdef CONFIG_NET_HW_FLOWCONTROL
+ 		if (netdev_dropping)
+ 			netdev_wakeup();
+ #else
+ 		netdev_dropping = 0;
+ #endif
+ 	}
+ }
+ 
+ /*
+  *	Receive a packet from a device driver and queue it for the upper
+  *	(protocol) levels.  It always succeeds. 
+  */
+ 
+ void netif_rx(struct sk_buff *skb)
+ {
+ #ifndef CONFIG_CPU_IS_SLOW
+ 	if(skb->stamp.tv_sec==0)
+ 		get_fast_time(&skb->stamp);
+ #else
+ 	skb->stamp = xtime;
+ #endif
+ 
+ 	/* The code is rearranged so that the path is the most
+ 	   short when CPU is congested, but is still operating.
+ 	 */
+ 
+ 	if (backlog.qlen <= netdev_max_backlog) {
+ 		if (backlog.qlen) {
+ 			if (netdev_dropping == 0) {
+ 				if (skb->dev->flags & IFF_SLAVE  && 
+ 				    skb->dev->slave) {
+ 					skb->dev = skb->dev->slave;
+ 				}
+ 				skb_queue_tail(&backlog,skb);
+ 				mark_bh(NET_BH);
+ 				return;
+ 			}
+ 			atomic_inc(&netdev_rx_dropped);
+ 			kfree_skb(skb);
+ 			return;
+ 		}
+ #ifdef CONFIG_NET_HW_FLOWCONTROL
+ 		if (netdev_dropping)
+ 			netdev_wakeup();
+ #else
+ 		netdev_dropping = 0;
+ #endif
+ 		if (skb->dev->flags & IFF_SLAVE  &&  skb->dev->slave) {
+ 			skb->dev = skb->dev->slave;
+ 		}
+ 		skb_queue_tail(&backlog,skb);
+ 		mark_bh(NET_BH);
+ 		return;
+ 	}
+ 	netdev_dropping = 1;
+ 	atomic_inc(&netdev_rx_dropped);
+ 	kfree_skb(skb);
+ }
+ 
+ #ifdef CONFIG_BRIDGE
+ static inline void handle_bridge(struct sk_buff *skb, unsigned short type)
+ {
+ 	/* 
+ 	 * The br_stats.flags is checked here to save the expense of a 
+ 	 * function call.
+ 	 */
+ 	if ((br_stats.flags & BR_UP) && br_call_bridge(skb, type))
+ 	{
+ 		/*
+ 		 *	We pass the bridge a complete frame. This means
+ 		 *	recovering the MAC header first.
+ 		 */
+ 		
+ 		int offset;
+ 
+ 		skb=skb_clone(skb, GFP_ATOMIC);
+ 		if(skb==NULL)		
+ 			return;
+ 			
+ 		offset = skb->data - skb->mac.raw;
+ 		skb_push(skb,offset);	/* Put header back on for bridge */
+ 
+ 		if(br_receive_frame(skb))
+ 			return;
+ 		kfree_skb(skb);
+ 	}
+ 	return;
+ }
+ #endif
+ 
+ /*
+  *	When we are called the queue is ready to grab, the interrupts are
+  *	on and hardware can interrupt and queue to the receive queue as we
+  *	run with no problems.
+  *	This is run as a bottom half after an interrupt handler that does
+  *	mark_bh(NET_BH);
+  */
+  
+ void net_bh(void)
+ {
+ 	struct packet_type *ptype;
+ 	struct packet_type *pt_prev;
+ 	unsigned short type;
+ 	unsigned long start_time = jiffies;
+ #ifdef CONFIG_CPU_IS_SLOW
+ 	static unsigned long start_busy = 0;
+ 	static unsigned long ave_busy = 0;
+ 
+ 	if (start_busy == 0)
+ 		start_busy = start_time;
+ 	net_cpu_congestion = ave_busy>>8;
+ #endif
+ 
+ 	NET_PROFILE_ENTER(net_bh);
+ 	/*
+ 	 *	Can we send anything now? We want to clear the
+ 	 *	decks for any more sends that get done as we
+ 	 *	process the input. This also minimises the
+ 	 *	latency on a transmit interrupt bh.
+ 	 */
+ 
+ 	if (qdisc_head.forw != &qdisc_head)
+ 		qdisc_run_queues();
+   
+ 	/*
+ 	 *	Any data left to process. This may occur because a
+ 	 *	mark_bh() is done after we empty the queue including
+ 	 *	that from the device which does a mark_bh() just after
+ 	 */
+ 
+ 	/*
+ 	 *	While the queue is not empty..
+ 	 *
+ 	 *	Note that the queue never shrinks due to
+ 	 *	an interrupt, so we can do this test without
+ 	 *	disabling interrupts.
+ 	 */
+ 
+ 	while (!skb_queue_empty(&backlog)) 
+ 	{
+ 		struct sk_buff * skb;
+ 
+ 		/* Give chance to other bottom halves to run */
+ 		if (jiffies - start_time > 1)
+ 			goto net_bh_break;
+ 
+ 		/*
+ 		 *	We have a packet. Therefore the queue has shrunk
+ 		 */
+ 		skb = skb_dequeue(&backlog);
+ 
+ #ifdef CONFIG_CPU_IS_SLOW
+ 		if (ave_busy > 128*16) {
+ 			kfree_skb(skb);
+ 			while ((skb = skb_dequeue(&backlog)) != NULL)
+ 				kfree_skb(skb);
+ 			break;
+ 		}
+ #endif
+ 
+ 
+ #if 0
+ 		NET_PROFILE_SKB_PASSED(skb, net_bh_skb);
+ #endif
+ #ifdef CONFIG_NET_FASTROUTE
+ 		if (skb->pkt_type == PACKET_FASTROUTE) {
+ 			dev_queue_xmit(skb);
+ 			continue;
+ 		}
+ #endif
+ 
+ 		/*
+ 	 	 *	Bump the pointer to the next structure.
+ 		 * 
+ 		 *	On entry to the protocol layer. skb->data and
+ 		 *	skb->nh.raw point to the MAC and encapsulated data
+ 		 */
+ 
+ 		/* XXX until we figure out every place to modify.. */
+ 		skb->h.raw = skb->nh.raw = skb->data;
+ 
+ 		if (skb->mac.raw < skb->head || skb->mac.raw > skb->data) {
+ 			printk(KERN_CRIT "%s: wrong mac.raw ptr, proto=%04x\n", skb->dev->name, skb->protocol);
+ 			kfree_skb(skb);
+ 			continue;
+ 		}
+ 
+ 		/*
+ 		 * 	Fetch the packet protocol ID. (In Network Byte Order --BLG)
+ 		 */
+ 
+ 		type = skb->protocol;
+ 
+ #ifdef CONFIG_BRIDGE
+ 		/*
+ 		 *	If we are bridging then pass the frame up to the
+ 		 *	bridging code (if this protocol is to be bridged).
+ 		 *      If it is bridged then move on
+ 		 */
+ 		handle_bridge(skb, type); 
+ #endif
+ 
+ 		/*
+ 		 *	We got a packet ID.  Now loop over the "known protocols"
+ 		 * 	list. There are two lists. The ptype_all list of taps (normally empty)
+ 		 *	and the main protocol list which is hashed perfectly for normal protocols.
+ 		 */
+ 
+ 		pt_prev = NULL;
+ 		for (ptype = ptype_all; ptype!=NULL; ptype=ptype->next)
+ 		{
+ 			if (!ptype->dev || ptype->dev == skb->dev) {
+ 				if(pt_prev)
+ 				{
+ 					struct sk_buff *skb2=skb_clone(skb, GFP_ATOMIC);
+ 					if(skb2)
+ 						pt_prev->func(skb2,skb->dev, pt_prev);
+ 				}
+ 				pt_prev=ptype;
+ 			}
+ 		}
+ 
+ 		for (ptype = ptype_base[ntohs(type)&15]; ptype != NULL; ptype = ptype->next) 
+ 		{
+ 			if (ptype->type == type && (!ptype->dev || ptype->dev==skb->dev))
+ 			{
+ 				/*
+ 				 *	We already have a match queued. Deliver
+ 				 *	to it and then remember the new match
+ 				 */
+ 				if(pt_prev)
+ 				{
+ 					struct sk_buff *skb2;
+ 
+ 					skb2=skb_clone(skb, GFP_ATOMIC);
+ 
+ 					/*
+ 					 *	Kick the protocol handler. This should be fast
+ 					 *	and efficient code.
+ 					 */
+ 
+ 					if(skb2)
+ 						pt_prev->func(skb2, skb->dev, pt_prev);
+ 				}
+ 				/* Remember the current last to do */
+ 				pt_prev=ptype;
+ 			}
+ 		} /* End of protocol list loop */
+ 
+ 		/*
+ 		 *	Is there a last item to send to ?
+ 		 */
+ 
+ 		if(pt_prev)
+ 			pt_prev->func(skb, skb->dev, pt_prev);
+ 		/*
+ 		 * 	Has an unknown packet has been received ?
+ 		 */
+ 	 
+ 		else {
+ 			kfree_skb(skb);
+ 		}
+   	}	/* End of queue loop */
+   	
+   	/*
+   	 *	We have emptied the queue
+   	 */
+ 	
+ 	/*
+ 	 *	One last output flush.
+ 	 */
+ 
+ 	if (qdisc_head.forw != &qdisc_head)
+ 		qdisc_run_queues();
+ 
+ #ifdef  CONFIG_CPU_IS_SLOW
+         if (1) {
+ 		unsigned long start_idle = jiffies;
+ 		ave_busy += ((start_idle - start_busy)<<3) - (ave_busy>>4);
+ 		start_busy = 0;
+ 	}
+ #endif
+ #ifdef CONFIG_NET_HW_FLOWCONTROL
+ 	if (netdev_dropping)
+ 		netdev_wakeup();
+ #else
+ 	netdev_dropping = 0;
+ #endif
+ 	NET_PROFILE_LEAVE(net_bh);
+ 	return;
+ 
+ net_bh_break:
+ 	mark_bh(NET_BH);
+ 	NET_PROFILE_LEAVE(net_bh);
+ 	return;
+ }
+ 
+ /* Protocol dependent address dumping routines */
+ 
+ static gifconf_func_t * gifconf_list [NPROTO];
+ 
+ int register_gifconf(unsigned int family, gifconf_func_t * gifconf)
+ {
+ 	if (family>=NPROTO)
+ 		return -EINVAL;
+ 	gifconf_list[family] = gifconf;
+ 	return 0;
+ }
+ 
+ 
+ /*
+  *	Map an interface index to its name (SIOCGIFNAME)
+  */
+ 
+ /*
+  *	This call is useful, but I'd remove it too.
+  *
+  *	The reason is purely aestetical, it is the only call
+  *	from SIOC* family using struct ifreq in reversed manner.
+  *	Besides that, it is pretty silly to put "drawing" facility
+  *	to kernel, it is useful only to print ifindices
+  *	in readable form, is not it? --ANK
+  *
+  *	We need this ioctl for efficient implementation of the
+  *	if_indextoname() function required by the IPv6 API.  Without
+  *	it, we would have to search all the interfaces to find a
+  *	match.  --pb
+  */
+ 
+ static int dev_ifname(struct ifreq *arg)
+ {
+ 	struct device *dev;
+ 	struct ifreq ifr;
+ 	int err;
+ 
+ 	/*
+ 	 *	Fetch the caller's info block. 
+ 	 */
+ 	
+ 	err = copy_from_user(&ifr, arg, sizeof(struct ifreq));
+ 	if (err)
+ 		return -EFAULT;
+ 
+ 	dev = dev_get_by_index(ifr.ifr_ifindex);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	strcpy(ifr.ifr_name, dev->name);
+ 
+ 	err = copy_to_user(arg, &ifr, sizeof(struct ifreq));
+ 	return (err)?-EFAULT:0;
+ }
+ 
+ /*
+  *	Perform a SIOCGIFCONF call. This structure will change
+  *	size eventually, and there is nothing I can do about it.
+  *	Thus we will need a 'compatibility mode'.
+  */
+ 
+ static int dev_ifconf(char *arg)
+ {
+ 	struct ifconf ifc;
+ 	struct device *dev;
+ 	char *pos;
+ 	int len;
+ 	int total;
+ 	int i;
+ 
+ 	/*
+ 	 *	Fetch the caller's info block. 
+ 	 */
+ 	
+ 	if (copy_from_user(&ifc, arg, sizeof(struct ifconf)))
+ 		return -EFAULT;
+ 
+ 	pos = ifc.ifc_buf;
+ 	len = ifc.ifc_len;
+ 
+ 	/*
+ 	 *	Loop over the interfaces, and write an info block for each. 
+ 	 */
+ 
+ 	total = 0;
+ 	for (dev = dev_base; dev != NULL; dev = dev->next) {
+ 		for (i=0; i<NPROTO; i++) {
+ 			if (gifconf_list[i]) {
+ 				int done;
+ 				if (pos==NULL) {
+ 					done = gifconf_list[i](dev, NULL, 0);
+ 				} else {
+ 					done = gifconf_list[i](dev, pos+total, len-total);
+ 				}
+ 				if (done<0)
+ 					return -EFAULT;
+ 				total += done;
+ 			}
+ 		}
+   	}
+ 
+ 	/*
+ 	 *	All done.  Write the updated control block back to the caller. 
+ 	 */
+ 	ifc.ifc_len = total;
+ 
+ 	if (copy_to_user(arg, &ifc, sizeof(struct ifconf)))
+ 		return -EFAULT; 
+ 
+ 	/* 
+ 	 * 	Both BSD and Solaris return 0 here, so we do too.
+ 	 */
+ 	return 0;
+ }
+ 
+ /*
+  *	This is invoked by the /proc filesystem handler to display a device
+  *	in detail.
+  */
+ 
+ #ifdef CONFIG_PROC_FS
+ static int sprintf_stats(char *buffer, struct device *dev)
+ {
+ 	struct net_device_stats *stats = (dev->get_stats ? dev->get_stats(dev): NULL);
+ 	int size;
+ 	
+ 	if (stats)
+ 		size = sprintf(buffer, "%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu %8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu\n",
+  		   dev->name,
+ 		   stats->rx_bytes,
+ 		   stats->rx_packets, stats->rx_errors,
+ 		   stats->rx_dropped + stats->rx_missed_errors,
+ 		   stats->rx_fifo_errors,
+ 		   stats->rx_length_errors + stats->rx_over_errors
+ 		   + stats->rx_crc_errors + stats->rx_frame_errors,
+ 		   stats->rx_compressed, stats->multicast,
+ 		   stats->tx_bytes,
+ 		   stats->tx_packets, stats->tx_errors, stats->tx_dropped,
+ 		   stats->tx_fifo_errors, stats->collisions,
+ 		   stats->tx_carrier_errors + stats->tx_aborted_errors
+ 		   + stats->tx_window_errors + stats->tx_heartbeat_errors,
+ 		   stats->tx_compressed);
+ 	else
+ 		size = sprintf(buffer, "%6s: No statistics available.\n", dev->name);
+ 
+ 	return size;
+ }
+ 
+ /*
+  *	Called from the PROCfs module. This now uses the new arbitrary sized /proc/net interface
+  *	to create /proc/net/dev
+  */
+  
+ int dev_get_info(char *buffer, char **start, off_t offset, int length, int dummy)
+ {
+ 	int len=0;
+ 	off_t begin=0;
+ 	off_t pos=0;
+ 	int size;
+ 	
+ 	struct device *dev;
+ 
+ 
+ 	size = sprintf(buffer, 
+ 		"Inter-|   Receive                                                |  Transmit\n"
+ 		" face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n");
+ 	
+ 	pos+=size;
+ 	len+=size;
+ 	
+ 
+ 	for (dev = dev_base; dev != NULL; dev = dev->next) 
+ 	{
+ 		size = sprintf_stats(buffer+len, dev);
+ 		len+=size;
+ 		pos=begin+len;
+ 				
+ 		if(pos<offset)
+ 		{
+ 			len=0;
+ 			begin=pos;
+ 		}
+ 		if(pos>offset+length)
+ 			break;
+ 	}
+ 	
+ 	*start=buffer+(offset-begin);	/* Start of wanted data */
+ 	len-=(offset-begin);		/* Start slop */
+ 	if(len>length)
+ 		len=length;		/* Ending slop */
+ 	return len;
+ }
+ 
+ static int dev_proc_stats(char *buffer, char **start, off_t offset,
+ 			  int length, int *eof, void *data)
+ {
+ 	int len;
+ 
+ 	len = sprintf(buffer, "%08x %08x %08x %08x %08x\n",
+ 		      atomic_read(&netdev_rx_dropped),
+ #ifdef CONFIG_NET_HW_FLOWCONTROL
+ 		      netdev_throttle_events,
+ #else
+ 		      0,
+ #endif
+ #ifdef CONFIG_NET_FASTROUTE
+ 		      dev_fastroute_stat.hits,
+ 		      dev_fastroute_stat.succeed,
+ 		      dev_fastroute_stat.deferred
+ #else
+ 		      0, 0, 0
+ #endif
+ 		      );
+ 
+ 	len -= offset;
+ 
+ 	if (len > length)
+ 		len = length;
+ 	if(len < 0)
+ 		len = 0;
+ 
+ 	*start = buffer + offset;
+ 	*eof = 1;
+ 
+ 	return len;
+ }
+ 
+ #endif	/* CONFIG_PROC_FS */
+ 
+ 
+ #ifdef CONFIG_NET_RADIO
+ #ifdef CONFIG_PROC_FS
+ 
+ /*
+  * Print one entry of /proc/net/wireless
+  * This is a clone of /proc/net/dev (just above)
+  */
+ static int sprintf_wireless_stats(char *buffer, struct device *dev)
+ {
+ 	/* Get stats from the driver */
+ 	struct iw_statistics *stats = (dev->get_wireless_stats ?
+ 				       dev->get_wireless_stats(dev) :
+ 				       (struct iw_statistics *) NULL);
+ 	int size;
+ 
+ 	if(stats != (struct iw_statistics *) NULL)
+ 	{
+ 		size = sprintf(buffer,
+ 			       "%6s: %04x  %3d%c  %3d%c  %3d%c  %6d %6d %6d\n",
+ 			       dev->name,
+ 			       stats->status,
+ 			       stats->qual.qual,
+ 			       stats->qual.updated & 1 ? '.' : ' ',
+ 			       stats->qual.level,
+ 			       stats->qual.updated & 2 ? '.' : ' ',
+ 			       stats->qual.noise,
+ 			       stats->qual.updated & 4 ? '.' : ' ',
+ 			       stats->discard.nwid,
+ 			       stats->discard.code,
+ 			       stats->discard.misc);
+ 		stats->qual.updated = 0;
+ 	}
+ 	else
+ 		size = 0;
+ 
+ 	return size;
+ }
+ 
+ /*
+  * Print info for /proc/net/wireless (print all entries)
+  * This is a clone of /proc/net/dev (just above)
+  */
+ int dev_get_wireless_info(char * buffer, char **start, off_t offset,
+ 			  int length, int dummy)
+ {
+ 	int		len = 0;
+ 	off_t		begin = 0;
+ 	off_t		pos = 0;
+ 	int		size;
+ 	
+ 	struct device *	dev;
+ 
+ 	size = sprintf(buffer,
+ 		       "Inter-| sta-|   Quality        |   Discarded packets\n"
+ 		       " face | tus | link level noise |  nwid  crypt   misc\n"
+ 			);
+ 	
+ 	pos+=size;
+ 	len+=size;
+ 
+ 	for(dev = dev_base; dev != NULL; dev = dev->next) 
+ 	{
+ 		size = sprintf_wireless_stats(buffer+len, dev);
+ 		len+=size;
+ 		pos=begin+len;
+ 
+ 		if(pos < offset)
+ 		{
+ 			len=0;
+ 			begin=pos;
+ 		}
+ 		if(pos > offset + length)
+ 			break;
+ 	}
+ 
+ 	*start = buffer + (offset - begin);	/* Start of wanted data */
+ 	len -= (offset - begin);		/* Start slop */
+ 	if(len > length)
+ 		len = length;		/* Ending slop */
+ 
+ 	return len;
+ }
+ #endif	/* CONFIG_PROC_FS */
+ #endif	/* CONFIG_NET_RADIO */
+ 
+ void dev_set_promiscuity(struct device *dev, int inc)
+ {
+ 	unsigned short old_flags = dev->flags;
+ 
+ 	dev->flags |= IFF_PROMISC;
+ 	if ((dev->promiscuity += inc) == 0)
+ 		dev->flags &= ~IFF_PROMISC;
+ 	if (dev->flags^old_flags) {
+ #ifdef CONFIG_NET_FASTROUTE
+ 		if (dev->flags&IFF_PROMISC) {
+ 			netdev_fastroute_obstacles++;
+ 			dev_clear_fastroute(dev);
+ 		} else
+ 			netdev_fastroute_obstacles--;
+ #endif
+ 		dev_mc_upload(dev);
+ 		printk(KERN_INFO "device %s %s promiscuous mode\n",
+ 		       dev->name, (dev->flags&IFF_PROMISC) ? "entered" : "left");
+ 	}
+ }
+ 
+ void dev_set_allmulti(struct device *dev, int inc)
+ {
+ 	unsigned short old_flags = dev->flags;
+ 
+ 	dev->flags |= IFF_ALLMULTI;
+ 	if ((dev->allmulti += inc) == 0)
+ 		dev->flags &= ~IFF_ALLMULTI;
+ 	if (dev->flags^old_flags)
+ 		dev_mc_upload(dev);
+ }
+ 
+ int dev_change_flags(struct device *dev, unsigned flags)
+ {
+ 	int ret;
+ 	int old_flags = dev->flags;
+ 
+ 	/*
+ 	 *	Set the flags on our device.
+ 	 */
+ 
+ 	dev->flags = (flags & (IFF_DEBUG|IFF_NOTRAILERS|IFF_RUNNING|IFF_NOARP|
+ 			       IFF_SLAVE|IFF_MASTER|IFF_DYNAMIC|
+ 			       IFF_MULTICAST|IFF_PORTSEL|IFF_AUTOMEDIA)) |
+ 				       (dev->flags & (IFF_UP|IFF_VOLATILE|IFF_PROMISC|IFF_ALLMULTI));
+ 
+ 	/*
+ 	 *	Load in the correct multicast list now the flags have changed.
+ 	 */				
+ 
+ 	dev_mc_upload(dev);
+ 
+ 	/*
+ 	 *	Have we downed the interface. We handle IFF_UP ourselves
+ 	 *	according to user attempts to set it, rather than blindly
+ 	 *	setting it.
+ 	 */
+ 
+ 	ret = 0;
+ 	if ((old_flags^flags)&IFF_UP)	/* Bit is different  ? */
+ 	{
+ 		ret = ((old_flags & IFF_UP) ? dev_close : dev_open)(dev);
+ 
+ 		if (ret == 0) 
+ 			dev_mc_upload(dev);
+ 	}
+ 
+ 	if (dev->flags&IFF_UP &&
+ 	    ((old_flags^dev->flags)&~(IFF_UP|IFF_RUNNING|IFF_PROMISC|IFF_ALLMULTI|IFF_VOLATILE)))
+ 		notifier_call_chain(&netdev_chain, NETDEV_CHANGE, dev);
+ 
+ 	if ((flags^dev->gflags)&IFF_PROMISC) {
+ 		int inc = (flags&IFF_PROMISC) ? +1 : -1;
+ 		dev->gflags ^= IFF_PROMISC;
+ 		dev_set_promiscuity(dev, inc);
+ 	}
+ 
+ 	/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI
+ 	   is important. Some (broken) drivers set IFF_PROMISC, when
+ 	   IFF_ALLMULTI is requested not asking us and not reporting.
+ 	 */
+ 	if ((flags^dev->gflags)&IFF_ALLMULTI) {
+ 		int inc = (flags&IFF_ALLMULTI) ? +1 : -1;
+ 		dev->gflags ^= IFF_ALLMULTI;
+ 		dev_set_allmulti(dev, inc);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+  *	Perform the SIOCxIFxxx calls. 
+  */
+  
+ static int dev_ifsioc(struct ifreq *ifr, unsigned int cmd)
+ {
+ 	struct device *dev;
+ 	int err;
+ 
+ 	if ((dev = dev_get(ifr->ifr_name)) == NULL)
+ 		return -ENODEV;
+ 
+ 	switch(cmd) 
+ 	{
+ 		case SIOCGIFFLAGS:	/* Get interface flags */
+ 			ifr->ifr_flags = (dev->flags&~(IFF_PROMISC|IFF_ALLMULTI))
+ 				|(dev->gflags&(IFF_PROMISC|IFF_ALLMULTI));
+ 			return 0;
+ 
+ 		case SIOCSIFFLAGS:	/* Set interface flags */
+ 			return dev_change_flags(dev, ifr->ifr_flags);
+ 		
+ 		case SIOCGIFMETRIC:	/* Get the metric on the interface (currently unused) */
+ 			ifr->ifr_metric = 0;
+ 			return 0;
+ 			
+ 		case SIOCSIFMETRIC:	/* Set the metric on the interface (currently unused) */
+ 			return -EOPNOTSUPP;
+ 	
+ 		case SIOCGIFMTU:	/* Get the MTU of a device */
+ 			ifr->ifr_mtu = dev->mtu;
+ 			return 0;
+ 	
+ 		case SIOCSIFMTU:	/* Set the MTU of a device */
+ 			if (ifr->ifr_mtu == dev->mtu)
+ 				return 0;
+ 
+ 			/*
+ 			 *	MTU must be positive.
+ 			 */
+ 			 
+ 			if (ifr->ifr_mtu<=0)
+ 				return -EINVAL;
+ 
+ 			if (dev->change_mtu)
+ 				err = dev->change_mtu(dev, ifr->ifr_mtu);
+ 			else {
+ 				dev->mtu = ifr->ifr_mtu;
+ 				err = 0;
+ 			}
+ 			if (!err && dev->flags&IFF_UP)
+ 				notifier_call_chain(&netdev_chain, NETDEV_CHANGEMTU, dev);
+ 			return err;
+ 
+ 		case SIOCGIFHWADDR:
+ 			memcpy(ifr->ifr_hwaddr.sa_data,dev->dev_addr, MAX_ADDR_LEN);
+ 			ifr->ifr_hwaddr.sa_family=dev->type;
+ 			return 0;
+ 				
+ 		case SIOCSIFHWADDR:
+ 			if(dev->set_mac_address==NULL)
+ 				return -EOPNOTSUPP;
+ 			if(ifr->ifr_hwaddr.sa_family!=dev->type)
+ 				return -EINVAL;
+ 			err=dev->set_mac_address(dev,&ifr->ifr_hwaddr);
+ 			if (!err)
+ 				notifier_call_chain(&netdev_chain, NETDEV_CHANGEADDR, dev);
+ 			return err;
+ 			
+ 		case SIOCSIFHWBROADCAST:
+ 			if(ifr->ifr_hwaddr.sa_family!=dev->type)
+ 				return -EINVAL;
+ 			memcpy(dev->broadcast, ifr->ifr_hwaddr.sa_data, MAX_ADDR_LEN);
+ 			notifier_call_chain(&netdev_chain, NETDEV_CHANGEADDR, dev);
+ 			return 0;
+ 
+ 		case SIOCGIFMAP:
+ 			ifr->ifr_map.mem_start=dev->mem_start;
+ 			ifr->ifr_map.mem_end=dev->mem_end;
+ 			ifr->ifr_map.base_addr=dev->base_addr;
+ 			ifr->ifr_map.irq=dev->irq;
+ 			ifr->ifr_map.dma=dev->dma;
+ 			ifr->ifr_map.port=dev->if_port;
+ 			return 0;
+ 			
+ 		case SIOCSIFMAP:
+ 			if (dev->set_config)
+ 				return dev->set_config(dev,&ifr->ifr_map);
+ 			return -EOPNOTSUPP;
+ 			
+ 		case SIOCADDMULTI:
+ 			if(dev->set_multicast_list==NULL ||
+ 			   ifr->ifr_hwaddr.sa_family!=AF_UNSPEC)
+ 				return -EINVAL;
+ 			dev_mc_add(dev,ifr->ifr_hwaddr.sa_data, dev->addr_len, 1);
+ 			return 0;
+ 
+ 		case SIOCDELMULTI:
+ 			if(dev->set_multicast_list==NULL ||
+ 			   ifr->ifr_hwaddr.sa_family!=AF_UNSPEC)
+ 				return -EINVAL;
+ 			dev_mc_delete(dev,ifr->ifr_hwaddr.sa_data,dev->addr_len, 1);
+ 			return 0;
+ 
+ 		case SIOCGIFINDEX:
+ 			ifr->ifr_ifindex = dev->ifindex;
+ 			return 0;
+ 
+ 		case SIOCGIFTXQLEN:
+ 			ifr->ifr_qlen = dev->tx_queue_len;
+ 			return 0;
+ 
+ 		case SIOCSIFTXQLEN:
+ 			if(ifr->ifr_qlen<0)
+ 				return -EINVAL;
+ 			dev->tx_queue_len = ifr->ifr_qlen;
+ 			return 0;
+ 
+ 		case SIOCSIFNAME:
+ 			if (dev->flags&IFF_UP)
+ 				return -EBUSY;
+ 			if (dev_get(ifr->ifr_newname))
+ 				return -EEXIST;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         /* Doesn't seem to need any additional locking in kernel 2.2 series... --Ben */
+                         __fdl_unregister_netdevice(dev); /* take it out of the name hash table */
+ #endif
+ 			memcpy(dev->name, ifr->ifr_newname, IFNAMSIZ);
+ 			dev->name[IFNAMSIZ-1] = 0;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         __fdl_register_netdevice(dev); /* put it back in the name hash table, with the new name */
+ #endif
+ 			notifier_call_chain(&netdev_chain, NETDEV_CHANGENAME, dev);
+ 			return 0;
+ 
+ 		/*
+ 		 *	Unknown or private ioctl
+ 		 */
+ 
+ 		default:
+ 			if(cmd >= SIOCDEVPRIVATE &&
+ 			   cmd <= SIOCDEVPRIVATE + 15) {
+ 				if (dev->do_ioctl)
+ 					return dev->do_ioctl(dev, ifr, cmd);
+ 				return -EOPNOTSUPP;
+ 			}
+ 
+ #ifdef CONFIG_NET_RADIO
+ 			if(cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {
+ 				if (dev->do_ioctl)
+ 					return dev->do_ioctl(dev, ifr, cmd);
+ 				return -EOPNOTSUPP;
+ 			}
+ #endif	/* CONFIG_NET_RADIO */
+ 
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ 
+ /*
+  *	This function handles all "interface"-type I/O control requests. The actual
+  *	'doing' part of this is dev_ifsioc above.
+  */
+ 
+ int dev_ioctl(unsigned int cmd, void *arg)
+ {
+ 	struct ifreq ifr;
+ 	int ret;
+ 	char *colon;
+ 
+ 	/* One special case: SIOCGIFCONF takes ifconf argument
+ 	   and requires shared lock, because it sleeps writing
+ 	   to user space.
+ 	 */
+ 	   
+ 	if (cmd == SIOCGIFCONF) {
+ 		rtnl_shlock();
+ 		ret = dev_ifconf((char *) arg);
+ 		rtnl_shunlock();
+ 		return ret;
+ 	}
+ 	if (cmd == SIOCGIFNAME) {
+ 		return dev_ifname((struct ifreq *)arg);
+ 	}
+ 
+ 	if (copy_from_user(&ifr, arg, sizeof(struct ifreq)))
+ 		return -EFAULT;
+ 
+ 	ifr.ifr_name[IFNAMSIZ-1] = 0;
+ 
+ 	colon = strchr(ifr.ifr_name, ':');
+ 	if (colon)
+ 		*colon = 0;
+ 
+ 	/*
+ 	 *	See which interface the caller is talking about. 
+ 	 */
+ 	 
+ 	switch(cmd) 
+ 	{
+ 		/*
+ 		 *	These ioctl calls:
+ 		 *	- can be done by all.
+ 		 *	- atomic and do not require locking.
+ 		 *	- return a value
+ 		 */
+ 		 
+ 		case SIOCGIFFLAGS:
+ 		case SIOCGIFMETRIC:
+ 		case SIOCGIFMTU:
+ 		case SIOCGIFHWADDR:
+ 		case SIOCGIFSLAVE:
+ 		case SIOCGIFMAP:
+ 		case SIOCGIFINDEX:
+ 		case SIOCGIFTXQLEN:
+ 			dev_load(ifr.ifr_name);
+ 			ret = dev_ifsioc(&ifr, cmd);
+ 			if (!ret) {
+ 				if (colon)
+ 					*colon = ':';
+ 				if (copy_to_user(arg, &ifr, sizeof(struct ifreq)))
+ 					return -EFAULT;
+ 			}
+ 			return ret;
+ 
+ 		/*
+ 		 *	These ioctl calls:
+ 		 *	- require superuser power.
+ 		 *	- require strict serialization.
+ 		 *	- do not return a value
+ 		 */
+ 		 
+ 		case SIOCSIFFLAGS:
+ 		case SIOCSIFMETRIC:
+ 		case SIOCSIFMTU:
+ 		case SIOCSIFMAP:
+ 		case SIOCSIFHWADDR:
+ 		case SIOCSIFSLAVE:
+ 		case SIOCADDMULTI:
+ 		case SIOCDELMULTI:
+ 		case SIOCSIFHWBROADCAST:
+ 		case SIOCSIFTXQLEN:
+ 		case SIOCSIFNAME:
+ 			if (!capable(CAP_NET_ADMIN))
+ 				return -EPERM;
+ 			dev_load(ifr.ifr_name);
+ 			rtnl_lock();
+ 			ret = dev_ifsioc(&ifr, cmd);
+ 			rtnl_unlock();
+ 			return ret;
+ 	
+ 		case SIOCGIFMEM:
+ 			/* Get the per device memory space. We can add this but currently
+ 			   do not support it */
+ 		case SIOCSIFMEM:
+ 			/* Set the per device memory buffer space. Not applicable in our case */
+ 		case SIOCSIFLINK:
+ 			return -EINVAL;
+ 
+ 		/*
+ 		 *	Unknown or private ioctl.
+ 		 */	
+ 		 
+ 		default:
+ 			if (cmd >= SIOCDEVPRIVATE &&
+ 			    cmd <= SIOCDEVPRIVATE + 15) {
+ 				dev_load(ifr.ifr_name);
+ 				rtnl_lock();
+ 				ret = dev_ifsioc(&ifr, cmd);
+ 				rtnl_unlock();
+ 				if (!ret && copy_to_user(arg, &ifr, sizeof(struct ifreq)))
+ 					return -EFAULT;
+ 				return ret;
+ 			}
+ #ifdef CONFIG_NET_RADIO
+ 			if (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {
+ 				dev_load(ifr.ifr_name);
+ 				if (IW_IS_SET(cmd)) {
+ 					if (!suser())
+ 						return -EPERM;
+ 					rtnl_lock();
+ 				}
+ 				ret = dev_ifsioc(&ifr, cmd);
+ 				if (IW_IS_SET(cmd))
+ 					rtnl_unlock();
+ 				if (!ret && IW_IS_GET(cmd) &&
+ 				    copy_to_user(arg, &ifr, sizeof(struct ifreq)))
+ 					return -EFAULT;
+ 				return ret;
+ 			}
+ #endif	/* CONFIG_NET_RADIO */
+ 			return -EINVAL;
+ 	}
+ }
+ 
+ int dev_new_index(void)
+ {
+ 	static int ifindex;
+ 	for (;;) {
+ 		if (++ifindex <= 0)
+ 			ifindex=1;
+ 		if (dev_get_by_index(ifindex) == NULL)
+ 			return ifindex;
+ 	}
+ }
+ 
+ static int dev_boot_phase = 1;
+ 
+ 
+ int register_netdevice(struct device *dev)
+ {
+ 	struct device *d, **dp;
+ 
+ 	if (dev_boot_phase) {
+ 		/* This is NOT bug, but I am not sure, that all the
+ 		   devices, initialized before netdev module is started
+ 		   are sane. 
+ 
+ 		   Now they are chained to device boot list
+ 		   and probed later. If a module is initialized
+ 		   before netdev, but assumes that dev->init
+ 		   is really called by register_netdev(), it will fail.
+ 
+ 		   So that this message should be printed for a while.
+ 		 */
+ 		printk(KERN_INFO "early initialization of device %s is deferred\n", dev->name);
+ 
+ 		/* Check for existence, and append to tail of chain */
+ 		for (dp=&dev_base; (d=*dp) != NULL; dp=&d->next) {
+ 			if (d == dev || strcmp(d->name, dev->name) == 0)
+ 				return -EEXIST;
+ 		}
+ 		dev->next = NULL;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                 /* Must do this before dp is set to dev, or it could be added twice, once
+                  * on initialization based on dev_base, and once again after that...
+                  */
+                 __fdl_register_netdevice(dev);
+ #endif
+ 		*dp = dev;
+ 		return 0;
+ 	}
+ 
+ 	dev->iflink = -1;
+ 
+ 	/* Init, if this function is available */
+ 	if (dev->init && dev->init(dev) != 0)
+ 		return -EIO;
+ 
+ 	/* Check for existence, and append to tail of chain */
+ 	for (dp=&dev_base; (d=*dp) != NULL; dp=&d->next) {
+ 		if (d == dev || strcmp(d->name, dev->name) == 0)
+ 			return -EEXIST;
+ 	}
+ 	dev->next = NULL;
+ 	dev_init_scheduler(dev);
+ 	dev->ifindex = dev_new_index();
+ 	if (dev->iflink == -1)
+ 		dev->iflink = dev->ifindex;
+ 
+ #ifdef BENS_FAST_DEV_LOOKUP
+         /* Must do this before dp is set to dev, or it could be added twice, once
+          * on initialization based on dev_base, and once again after that...
+          */
+         __fdl_register_netdevice(dev);
+ #endif
+ 	*dp = dev;
+ 
+ 	/* Notify protocols, that a new device appeared. */
+ 	notifier_call_chain(&netdev_chain, NETDEV_REGISTER, dev);
+ 
+ 	return 0;
+ }
+ 
+ int unregister_netdevice(struct device *dev)
+ {
+ 	struct device *d, **dp;
+ 
+ 	if (dev_boot_phase == 0) {
+ 		/* If device is running, close it.
+ 		   It is very bad idea, really we should
+ 		   complain loudly here, but random hackery
+ 		   in linux/drivers/net likes it.
+ 		 */
+ 		if (dev->flags & IFF_UP)
+ 			dev_close(dev);
+ 
+ #ifdef CONFIG_NET_FASTROUTE
+ 		dev_clear_fastroute(dev);
+ #endif
+ 
+ 		/* Shutdown queueing discipline. */
+ 		dev_shutdown(dev);
+ 
+ 		/* Notify protocols, that we are about to destroy
+ 		   this device. They should clean all the things.
+ 		 */
+ 		notifier_call_chain(&netdev_chain, NETDEV_UNREGISTER, dev);
+ 
+ 		/*
+ 		 *	Flush the multicast chain
+ 		 */
+ 		dev_mc_discard(dev);
+ 
+ 		/* To avoid pointers looking to nowhere,
+ 		   we wait for end of critical section */
+ 		dev_lock_wait();
+ 	}
+ 
+ 	/* And unlink it from device chain. */
+ 	for (dp = &dev_base; (d=*dp) != NULL; dp=&d->next) {
+ 		if (d == dev) {
+ 			*dp = d->next;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         __fdl_unregister_netdevice(dev);
+ #endif
+ 			synchronize_bh();
+ 			d->next = NULL;
+ 
+ 			if (dev->destructor)
+ 				dev->destructor(dev);
+ 			return 0;
+ 		}
+ 	}
+ 	return -ENODEV;
+ }
+ 
+ 
+ /*
+  *	Initialize the DEV module. At boot time this walks the device list and
+  *	unhooks any devices that fail to initialise (normally hardware not 
+  *	present) and leaves us with a valid list of present and active devices.
+  *
+  */
+ extern int lance_init(void);
+ extern int bpq_init(void);
+ extern int scc_init(void);
+ extern void sdla_setup(void);
+ extern void sdla_c_setup(void);
+ extern void dlci_setup(void);
+ extern int dmascc_init(void);
+ extern int sm_init(void);
+ 
+ extern int baycom_ser_fdx_init(void);
+ extern int baycom_ser_hdx_init(void);
+ extern int baycom_par_init(void);
+ 
+ extern int lapbeth_init(void);
+ extern int comx_init(void);
+ extern void arcnet_init(void);
+ extern void ip_auto_config(void);
+ #ifdef CONFIG_8xx
+ extern int cpm_enet_init(void);
+ #endif /* CONFIG_8xx */
+ 
+ #ifdef CONFIG_PROC_FS
+ static struct proc_dir_entry proc_net_dev = {
+ 	PROC_NET_DEV, 3, "dev",
+ 	S_IFREG | S_IRUGO, 1, 0, 0,
+ 	0, &proc_net_inode_operations,
+ 	dev_get_info
+ };
+ #endif
+ 
+ #ifdef CONFIG_NET_RADIO
+ #ifdef CONFIG_PROC_FS
+ static struct proc_dir_entry proc_net_wireless = {
+ 	PROC_NET_WIRELESS, 8, "wireless",
+ 	S_IFREG | S_IRUGO, 1, 0, 0,
+ 	0, &proc_net_inode_operations,
+ 	dev_get_wireless_info
+ };
+ #endif	/* CONFIG_PROC_FS */
+ #endif	/* CONFIG_NET_RADIO */
+ 
+ __initfunc(int net_dev_init(void))
+ {
+ 	struct device *dev, **dp;
+ 
+ #ifdef CONFIG_NET_SCHED
+ 	pktsched_init();
+ #endif
+ 
+ 	/*
+ 	 *	Initialise the packet receive queue.
+ 	 */
+ 	 
+ 	skb_queue_head_init(&backlog);
+ 	
+ 	/*
+ 	 *	The bridge has to be up before the devices
+ 	 */
+ 
+ #ifdef CONFIG_BRIDGE	 
+ 	br_init();
+ #endif	
+ 	
+ 	/*
+ 	 * This is Very Ugly(tm).
+ 	 *
+ 	 * Some devices want to be initialized early..
+ 	 */
+ 
+ #if defined(CONFIG_SCC)
+ 	scc_init();
+ #endif
+ #if defined(CONFIG_DMASCC)
+ 	dmascc_init();
+ #endif	
+ #if defined(CONFIG_BPQETHER)
+ 	bpq_init();
+ #endif
+ #if defined(CONFIG_DLCI)
+ 	dlci_setup();
+ #endif
+ #if defined(CONFIG_SDLA)
+ 	sdla_c_setup();
+ #endif
+ #if defined(CONFIG_BAYCOM_PAR)
+ 	baycom_par_init();
+ #endif
+ #if defined(CONFIG_BAYCOM_SER_FDX)
+ 	baycom_ser_fdx_init();
+ #endif
+ #if defined(CONFIG_BAYCOM_SER_HDX)
+ 	baycom_ser_hdx_init();
+ #endif
+ #if defined(CONFIG_SOUNDMODEM)
+ 	sm_init();
+ #endif
+ #if defined(CONFIG_LAPBETHER)
+ 	lapbeth_init();
+ #endif
+ #if defined(CONFIG_PLIP)
+ 	plip_init();
+ #endif
+ #if defined(CONFIG_ARCNET)
+ 	arcnet_init();
+ #endif
+ #if defined(CONFIG_8xx)
+         cpm_enet_init();
+ #endif
+ #if defined(CONFIG_COMX)
+ 	comx_init();
+ #endif
+ 
+ #ifdef CONFIG_NET_PROFILE
+ 	net_profile_init();
+ 	NET_PROFILE_REGISTER(dev_queue_xmit);
+ 	NET_PROFILE_REGISTER(net_bh);
+ #if 0
+ 	NET_PROFILE_REGISTER(net_bh_skb);
+ #endif
+ #endif
+ 	/*
+ 	 *	Add the devices.
+ 	 *	If the call to dev->init fails, the dev is removed
+ 	 *	from the chain disconnecting the device until the
+ 	 *	next reboot.
+ 	 */
+ 
+ 	dp = &dev_base;
+ 	while ((dev = *dp) != NULL)
+ 	{
+ 		dev->iflink = -1;
+ 		if (dev->init && dev->init(dev)) 
+ 		{
+ 			/*
+ 			 *	It failed to come up. Unhook it.
+ 			 */
+ 			*dp = dev->next;
+ 			synchronize_bh();
+ 		} 
+ 		else
+ 		{
+ 			dp = &dev->next;
+ 			dev->ifindex = dev_new_index();
+ 			if (dev->iflink == -1)
+ 				dev->iflink = dev->ifindex;
+ 			dev_init_scheduler(dev);
+ 		}
+ 	}
+ 
+ #ifdef CONFIG_PROC_FS
+ 	proc_net_register(&proc_net_dev);
+ 	{
+ 		struct proc_dir_entry *ent = create_proc_entry("net/dev_stat", 0, 0);
+ 		ent->read_proc = dev_proc_stats;
+ 	}
+ #endif
+ 
+ #ifdef CONFIG_NET_RADIO
+ #ifdef CONFIG_PROC_FS
+ 	proc_net_register(&proc_net_wireless);
+ #endif	/* CONFIG_PROC_FS */
+ #endif	/* CONFIG_NET_RADIO */
+ 
+ 	init_bh(NET_BH, net_bh);
+ 
+ 	dev_boot_phase = 0;
+ 
+ 	dev_mcast_init();
+ 
+ #ifdef CONFIG_BRIDGE
+ 	/*
+ 	 * Register any statically linked ethernet devices with the bridge
+ 	 */
+ 	br_spacedevice_register();
+ #endif
+ 
+ #ifdef CONFIG_N2
+ 	n2_init();
+ #endif
+ #ifdef CONFIG_C101
+ 	c101_init();
+ #endif
+ #ifdef CONFIG_WANXL
+ 	wanxl_init();
+ #endif
+ #ifdef CONFIG_PC300
+ 	cpc_init();
+ #endif
+ #ifdef CONFIG_HDLC
+ 	sync_ppp_init();
+ #endif
+ 
+ #ifdef CONFIG_IP_PNP
+ 	ip_auto_config();
+ #endif
+ 
+ 	return 0;
+ }
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/core/dev.c linux.dev/net/core/dev.c
*** linux/net/core/dev.c	Mon Sep  4 10:39:29 2000
--- linux.dev/net/core/dev.c	Sun Oct 15 15:15:15 2000
***************
*** 1,3 ****
! /*
   * 	NET3	Protocol independent device support routines.
   *
--- 1,3 ----
! /* -*- linux-c -*-
   * 	NET3	Protocol independent device support routines.
   *
***************
*** 93,96 ****
--- 93,101 ----
  #include <linux/wireless.h>
  #endif	/* CONFIG_NET_RADIO */
+ 
+ #ifdef CONFIG_VLAN_802_1Q
+ #include "../802_1Q/vlan.h"
+ #endif
+ 
  #ifdef CONFIG_PLIP
  extern int plip_init(void);
***************
*** 122,128 ****
   *
   *	Why 16. Because with 16 the only overlap we get on a hash of the
!  *	low nibble of the protocol value is RARP/SNAP/X.25. 
   *
   *		0800	IP
   *		0001	802.3
   *		0002	AX.25
--- 127,141 ----
   *
   *	Why 16. Because with 16 the only overlap we get on a hash of the
!  *	low nibble of the protocol value is RARP/SNAP/X.25.
!  *
!  *      NOTE:  That is no longer true with the addition of VLAN tags.  Not
!  *             sure which should go first, but I bet it won't make much
!  *             difference if we are running VLANs.  The good news is that
!  *             this protocol won't be in the list unless compiled in, so
!  *             the average user (w/out VLANs) will not be adversly affected.
!  *             --BLG
   *
   *		0800	IP
+  *		8100    802.1Q VLAN
   *		0001	802.3
   *		0002	AX.25
***************
*** 169,172 ****
--- 182,429 ----
  
  
+ #define BENS_FAST_DEV_LOOKUP
+ #ifdef BENS_FAST_DEV_LOOKUP
+ /* Fash Device Lookup code.  Should give much better than
+  * linear speed when looking for devices by idx or name.
+  * --Ben (greearb@candelatech.com)
+  */
+ #define FDL_HASH_LEN 256
+ 
+ /* #define FDL_DEBUG */
+ 
+ struct dev_hash_node {
+         struct device* dev;
+         struct dev_hash_node* next;
+ };
+ 
+ struct dev_hash_node* fdl_name_base[FDL_HASH_LEN];/* hashed by name */
+ struct dev_hash_node* fdl_idx_base[FDL_HASH_LEN]; /* hashed by index */
+ int fdl_initialized_yet = 0;
+ 
+ /* TODO:  Make these inline methods */
+ /* Nice cheesy little hash method to be used on device-names (eth0, ppp0, etc) */
+ int fdl_calc_name_idx(const char* dev_name) {
+         int tmp = 0;
+         int i;
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "fdl_calc_name_idx, name: %s\n", dev_name);
+ #endif
+         for (i = 0; dev_name[i]; i++) {
+                 tmp += (int)(dev_name[i]);
+         }
+         if (i > 3) {
+                 tmp += (dev_name[i-2] * 10); /* might add a little spread to the hash */
+                 tmp += (dev_name[i-3] * 100); /* might add a little spread to the hash */
+         }
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "fdl_calc_name_idx, rslt: %i\n", (int)(tmp % FDL_HASH_LEN));
+ #endif
+         return (tmp % FDL_HASH_LEN);
+ }
+ 
+ int fdl_calc_index_idx(const int ifindex) {
+         return (ifindex % FDL_HASH_LEN);
+ }
+ 
+ 
+ /* Better have a lock on the dev_base before calling this... */
+ int __fdl_ensure_init(void) {
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "__fdl_ensure_init, enter\n");
+ #endif
+         if (! fdl_initialized_yet) {
+                 /* only do this once.. */
+                 int i;
+                 int idx = 0; /* into the hash table */
+                 struct device* dev = dev_base;
+                 struct dev_hash_node* dhn;
+ 
+ #ifdef FDL_DEBUG
+                 printk(KERN_ERR "__fdl_ensure_init, doing real work...");
+ #endif
+ 
+                 fdl_initialized_yet = 1; /* it has been attempted at least... */
+ 
+                 for (i = 0; i<FDL_HASH_LEN; i++) {
+                         fdl_name_base[i] = NULL;
+                         fdl_idx_base[i] = NULL;
+                 }
+ 
+                 /* add any current devices to the hash tables at this time.  Note that
+                  * this method must be called with locks on the dev_base acquired.
+                  */
+                 while (dev) {
+ 
+ #ifdef FDL_DEBUG
+                         printk(KERN_ERR "__fdl_ensure_init, dev: %p dev: %s, idx: %i\n", dev, dev->name, idx);
+ #endif
+                         /* first, take care of the hash-by-name */
+                         idx = fdl_calc_name_idx(dev->name);
+                         dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+                         if (dhn) {
+                                 dhn->dev = dev;
+                                 dhn->next = fdl_name_base[idx];
+                                 fdl_name_base[idx] = dhn;
+                         }
+                         else {
+                                 /* Nasty..couldn't get memory... */
+                                 return -ENOMEM;
+                         }
+ 
+                         /* now, do the hash-by-idx */
+                         idx = fdl_calc_index_idx(dev->ifindex);
+                         dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+                         if (dhn) {
+                                 dhn->dev = dev;
+                                 dhn->next = fdl_idx_base[idx];
+                                 fdl_idx_base[idx] = dhn;
+                         }
+                         else {
+                                 /* Nasty..couldn't get memory... */
+                                 return -ENOMEM;
+                         }
+          
+                         dev = dev->next;
+                 }
+                 fdl_initialized_yet = 2; /* initialization actually worked */
+         }
+ #ifdef FDL_DEBUG
+         printk(KERN_ERR "__fdl_ensure_init, end, fdl_initialized_yet: %i\n", fdl_initialized_yet);
+ #endif
+         if (fdl_initialized_yet == 2) {
+                 return 0;
+         }
+         else {
+                 return -1;
+         }
+ }/* fdl_ensure_init */
+ 
+ 
+ /* called from register_netdevice, assumes dev is locked, and that no one
+  * will be calling __find_dev_by_name before this exits.. etc.
+  */
+ int __fdl_register_netdevice(struct device* dev) {
+         if (__fdl_ensure_init() == 0) {
+                 /* first, take care of the hash-by-name */
+                 int idx = fdl_calc_name_idx(dev->name);
+                 struct dev_hash_node* dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+ 
+ #ifdef FDL_DEBUG
+                 printk(KERN_ERR "__fdl_register_netdevice, dev: %p dev: %s, idx: %i", dev, dev->name, idx);
+ #endif
+ 
+                 if (dhn) {
+                         dhn->dev = dev;
+                         dhn->next = fdl_name_base[idx];
+                         fdl_name_base[idx] = dhn;
+                 }
+                 else {
+                         /* Nasty..couldn't get memory... */
+                         /* Don't try to use these hash tables any more... */
+                         fdl_initialized_yet = 1; /* tried, but failed */
+                         return -ENOMEM;
+                 }
+       
+                 /* now, do the hash-by-idx */
+                 idx = fdl_calc_index_idx(dev->ifindex);
+                 dhn = kmalloc(sizeof(struct dev_hash_node), GFP_ATOMIC);
+ 
+ #ifdef FDL_DEBUG
+                 printk(KERN_ERR "__fdl_register_netdevice, ifindex: %i, idx: %i", dev->ifindex, idx);
+ #endif
+ 
+                 if (dhn) {
+                         dhn->dev = dev;
+                         dhn->next = fdl_idx_base[idx];
+                         fdl_idx_base[idx] = dhn;
+                 }
+                 else {
+                         /* Nasty..couldn't get memory... */
+                         /* Don't try to use these hash tables any more... */
+                         fdl_initialized_yet = 1; /* tried, but failed */
+                         return -ENOMEM;
+                 }
+         }
+         return 0;
+ } /* fdl_register_netdevice */
+ 
+ 
+ /* called from register_netdevice, assumes dev is locked, and that no one
+  * will be calling __find_dev_by_name, etc.  Returns 0 if found & removed one,
+  * returns -1 otherwise.
+  */
+ int __fdl_unregister_netdevice(struct device* dev) {
+         int retval = -1;
+         if (fdl_initialized_yet == 2) { /* If we've been initialized correctly... */
+                 /* first, take care of the hash-by-name */
+                 int idx = fdl_calc_name_idx(dev->name);
+                 struct dev_hash_node* prev = fdl_name_base[idx];
+                 struct dev_hash_node* cur = NULL;
+ 
+ #ifdef FDL_DEBUG
+                 printk(KERN_ERR "__fdl_unregister_netdevice, dev: %p dev: %s, idx: %i", dev, dev->name, idx);
+ #endif
+ 
+                 if (prev) {
+                         if (strcmp(dev->name, prev->dev->name) == 0) {
+                                 /* it's the first one... */
+                                 fdl_name_base[idx] = prev->next;
+                                 kfree(prev);
+                                 retval = 0;
+                         }
+                         else {
+                                 cur = prev->next;
+                                 while (cur) {
+                                         if (strcmp(dev->name, cur->dev->name) == 0) {
+                                                 prev->next = cur->next;
+                                                 kfree(cur);
+                                                 retval = 0;
+                                                 break;
+                                         }
+                                         else {
+                                                 prev = cur;
+                                                 cur = cur->next;
+                                         }
+                                 }
+                         }
+                 }
+ 
+                 /* Now, the hash-by-index */
+                 idx = fdl_calc_index_idx(dev->ifindex);
+                 prev = fdl_idx_base[idx];
+                 cur = NULL;
+                 if (prev) {
+                         if (dev->ifindex == prev->dev->ifindex) {
+                                 /* it's the first one... */
+                                 fdl_idx_base[idx] = prev->next;
+                                 kfree(prev);
+                                 retval = 0;
+                         }
+                         else {
+                                 cur = prev->next;
+                                 while (cur) {
+                                         if (dev->ifindex == cur->dev->ifindex) {
+                                                 prev->next = cur->next;
+                                                 kfree(cur);
+                                                 retval = 0;
+                                                 break;
+                                         }
+                                         else {
+                                                 prev = cur;
+                                                 cur = cur->next;
+                                         }
+                                 }
+                         }
+                 }
+         }/* if we ensured init OK */
+         return retval;
+ } /* fdl_unregister_netdevice */
+ 
+ 
+ 
+ #endif   /* BENS_FAST_DEV_LOOKUP */
+ 
+ 
+ 
  /******************************************************************************************
  
***************
*** 266,269 ****
--- 523,545 ----
  	struct device *dev;
  
+ #ifdef BENS_FAST_DEV_LOOKUP
+         int idx = fdl_calc_name_idx(name);
+         struct dev_hash_node* dhn;
+         if (fdl_initialized_yet == 2) {
+ #ifdef FDL_DEBUG
+            printk(KERN_ERR "__dev_get_by_name, name: %s  idx: %i\n", name, idx);
+ #endif
+            dhn = fdl_name_base[idx];
+            while (dhn) {
+               if (strcmp(dhn->dev->name, name) == 0) {
+                  /* printk(KERN_ERR "__dev_get_by_name, found it: %p\n", dhn->dev); */
+                  return dhn->dev;
+               }
+               dhn = dhn->next;
+            }
+            /* printk(KERN_ERR "__dev_get_by_name, didn't find it for name: %s\n", name); */
+            return NULL;
+         }
+ #endif
  	for (dev = dev_base; dev != NULL; dev = dev->next) 
  	{
***************
*** 277,281 ****
  {
  	struct device *dev;
! 
  	for (dev = dev_base; dev != NULL; dev = dev->next) 
  	{
--- 553,569 ----
  {
  	struct device *dev;
! #ifdef BENS_FAST_DEV_LOOKUP
!         int idx = fdl_calc_index_idx(ifindex);
!         struct dev_hash_node* dhn;
!         if (fdl_initialized_yet == 2) { /* have we gone through initialization before... */
!            dhn = fdl_idx_base[idx];
!            while (dhn) {
!               if (dhn->dev->ifindex == ifindex)
!                  return dhn->dev;
!               dhn = dhn->next;
!            }
!            return NULL;
!         }
! #endif
  	for (dev = dev_base; dev != NULL; dev = dev->next) 
  	{
***************
*** 309,314 ****
  	/*
  	 *	If you need over 100 please also fix the algorithm...
! 	 */
! 	for(i=0;i<100;i++)
  	{
  		sprintf(dev->name,name,i);
--- 597,605 ----
  	/*
  	 *	If you need over 100 please also fix the algorithm...
!          *
!          *  Increased it to deal with VLAN interfaces.  It is unlikely
!          *  that this many will ever be added, but it can't hurt! -BLG
!          */
! 	for(i=0;i<8192;i++)
  	{
  		sprintf(dev->name,name,i);
***************
*** 316,320 ****
  			return i;
  	}
! 	return -ENFILE;	/* Over 100 of the things .. bail out! */
  }
   
--- 607,611 ----
  			return i;
  	}
! 	return -ENFILE;	/* Over 8192 of the things .. bail out! */
  }
   
***************
*** 829,833 ****
  			return;
  			
! 		offset=skb->data-skb->mac.raw;
  		skb_push(skb,offset);	/* Put header back on for bridge */
  
--- 1120,1124 ----
  			return;
  			
! 		offset = skb->data - skb->mac.raw;
  		skb_push(skb,offset);	/* Put header back on for bridge */
  
***************
*** 938,942 ****
  
  		/*
! 		 * 	Fetch the packet protocol ID. 
  		 */
  
--- 1229,1233 ----
  
  		/*
! 		 * 	Fetch the packet protocol ID. (In Network Byte Order --BLG)
  		 */
  
***************
*** 1576,1581 ****
--- 1867,1879 ----
  			if (dev_get(ifr->ifr_newname))
  				return -EEXIST;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         /* Doesn't seem to need any additional locking in kernel 2.2 series... --Ben */
+                         __fdl_unregister_netdevice(dev); /* take it out of the name hash table */
+ #endif
  			memcpy(dev->name, ifr->ifr_newname, IFNAMSIZ);
  			dev->name[IFNAMSIZ-1] = 0;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         __fdl_register_netdevice(dev); /* put it back in the name hash table, with the new name */
+ #endif
  			notifier_call_chain(&netdev_chain, NETDEV_CHANGENAME, dev);
  			return 0;
***************
*** 1780,1783 ****
--- 2078,2087 ----
  		}
  		dev->next = NULL;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                 /* Must do this before dp is set to dev, or it could be added twice, once
+                  * on initialization based on dev_base, and once again after that...
+                  */
+                 __fdl_register_netdevice(dev);
+ #endif
  		*dp = dev;
  		return 0;
***************
*** 1800,1803 ****
--- 2104,2114 ----
  	if (dev->iflink == -1)
  		dev->iflink = dev->ifindex;
+ 
+ #ifdef BENS_FAST_DEV_LOOKUP
+         /* Must do this before dp is set to dev, or it could be added twice, once
+          * on initialization based on dev_base, and once again after that...
+          */
+         __fdl_register_netdevice(dev);
+ #endif
  	*dp = dev;
  
***************
*** 1847,1850 ****
--- 2158,2164 ----
  		if (d == dev) {
  			*dp = d->next;
+ #ifdef BENS_FAST_DEV_LOOKUP
+                         __fdl_unregister_netdevice(dev);
+ #endif
  			synchronize_bh();
  			d->next = NULL;
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/ethernet/eth.c linux.dev/net/ethernet/eth.c
*** linux/net/ethernet/eth.c	Tue Jan  4 11:12:26 2000
--- linux.dev/net/ethernet/eth.c	Wed Oct 25 23:52:14 2000
***************
*** 175,178 ****
--- 175,181 ----
   *	assume 802.3 if the type field is short enough to be a length.
   *	This is normal practice and works for any 'now in use' protocol.
+  *
+  *  NOTE:  It is likely that you will want to change vlan_type_trans in
+  *         802_1Q/vlan.c if you change anything here.
   */
   
***************
*** 181,189 ****
  	struct ethhdr *eth;
  	unsigned char *rawp;
! 	
! 	skb->mac.raw=skb->data;
! 	skb_pull(skb,dev->hard_header_len);
! 	eth= skb->mac.ethernet;
! 	
  	if(*eth->h_dest&1)
  	{
--- 184,204 ----
  	struct ethhdr *eth;
  	unsigned char *rawp;
! 
!         skb->mac.raw=skb->data;
! 
! #ifdef CONFIG_VLAN_802_1Q
! 	/* Moving this below to be more selective.  Reason is that for VLAN
!          * devices, we do not want to pull the header, we'll let the VLAN
!          * device do that instead.  This makes default vlans (based on incoming
!          * port), much more sane!  --BLG
!          */
!         
!         /* skb_pull(skb,dev->hard_header_len); */
! #else
!         skb_pull(skb,dev->hard_header_len);
! #endif
!         
!         eth= skb->mac.ethernet;
! 
  	if(*eth->h_dest&1)
  	{
***************
*** 207,211 ****
  			skb->pkt_type=PACKET_OTHERHOST;
  	}
! 	
  	if (ntohs(eth->h_proto) >= 1536)
  		return eth->h_proto;
--- 222,240 ----
  			skb->pkt_type=PACKET_OTHERHOST;
  	}
! 
! #ifdef CONFIG_VLAN_802_1Q
!         if (ntohs(eth->h_proto) == ETH_P_802_1Q) {
!                 /* then we have to convert this into a VLAN looking packet.
!                  * We'll wait to do that in the VLAN protocol handler.
!                  *
!                  * NOTE:  We DO NOT PULL ANYTHING FROM THE SKB HERE!!!
!                  */
!                 return __constant_htons(ETH_P_802_1Q);
!         }
!         else {
!                 skb_pull(skb, dev->hard_header_len);
!         }
! #endif
!         
  	if (ntohs(eth->h_proto) >= 1536)
  		return eth->h_proto;
diff -P -C 2 -X /home/greear/exclude.list --recursive linux/net/protocols.c linux.dev/net/protocols.c
*** linux/net/protocols.c	Thu Dec 17 10:03:57 1998
--- linux.dev/net/protocols.c	Wed Oct 11 20:07:47 2000
***************
*** 35,38 ****
--- 35,42 ----
  #endif
  
+ #ifdef CONFIG_VLAN_802_1Q
+ extern void vlan_proto_init(struct net_proto* pro);
+ #endif
+ 
  #if defined(CONFIG_IPX) || defined(CONFIG_IPX_MODULE)
  #define NEED_802
***************
*** 170,173 ****
--- 174,181 ----
  #endif
  
+ #ifdef CONFIG_VLAN_802_1Q
+   { "VLAN",     vlan_proto_init },                    /* 802.1Q VLAN Support. --BLG */
+ #endif
+   
    { NULL,	NULL		}			/* End marker			*/
  };
